
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cobra: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/spf13/cobra/active_help.go (100.0%)</option>
				
				<option value="file1">github.com/spf13/cobra/args.go (100.0%)</option>
				
				<option value="file2">github.com/spf13/cobra/bash_completions.go (93.3%)</option>
				
				<option value="file3">github.com/spf13/cobra/bash_completionsV2.go (57.1%)</option>
				
				<option value="file4">github.com/spf13/cobra/cobra.go (100.0%)</option>
				
				<option value="file5">github.com/spf13/cobra/command.go (86.2%)</option>
				
				<option value="file6">github.com/spf13/cobra/completions.go (91.7%)</option>
				
				<option value="file7">github.com/spf13/cobra/fish_completions.go (100.0%)</option>
				
				<option value="file8">github.com/spf13/cobra/flag_groups.go (95.3%)</option>
				
				<option value="file9">github.com/spf13/cobra/powershell_completions.go (60.0%)</option>
				
				<option value="file10">github.com/spf13/cobra/shell_completions.go (90.9%)</option>
				
				<option value="file11">github.com/spf13/cobra/zsh_completions.go (52.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "fmt"
        "os"
)

const (
        activeHelpMarker = "_activeHelp_ "
        // The below values should not be changed: programs will be using them explicitly
        // in their user documentation, and users will be using them explicitly.
        activeHelpEnvVarSuffix  = "ACTIVE_HELP"
        activeHelpGlobalEnvVar  = configEnvVarGlobalPrefix + "_" + activeHelpEnvVarSuffix
        activeHelpGlobalDisable = "0"
)

// AppendActiveHelp adds the specified string to the specified array to be used as ActiveHelp.
// Such strings will be processed by the completion script and will be shown as ActiveHelp
// to the user.
// The array parameter should be the array that will contain the completions.
// This function can be called multiple times before and/or after completions are added to
// the array.  Each time this function is called with the same array, the new
// ActiveHelp line will be shown below the previous ones when completion is triggered.
func AppendActiveHelp(compArray []string, activeHelpStr string) []string <span class="cov8" title="1">{
        return append(compArray, fmt.Sprintf("%s%s", activeHelpMarker, activeHelpStr))
}</span>

// GetActiveHelpConfig returns the value of the ActiveHelp environment variable
// &lt;PROGRAM&gt;_ACTIVE_HELP where &lt;PROGRAM&gt; is the name of the root command in upper
// case, with all non-ASCII-alphanumeric characters replaced by `_`.
// It will always return "0" if the global environment variable COBRA_ACTIVE_HELP
// is set to "0".
func GetActiveHelpConfig(cmd *Command) string <span class="cov8" title="1">{
        activeHelpCfg := os.Getenv(activeHelpGlobalEnvVar)
        if activeHelpCfg != activeHelpGlobalDisable </span><span class="cov8" title="1">{
                activeHelpCfg = os.Getenv(activeHelpEnvVar(cmd.Root().Name()))
        }</span>
        <span class="cov8" title="1">return activeHelpCfg</span>
}

// activeHelpEnvVar returns the name of the program-specific ActiveHelp environment
// variable.  It has the format &lt;PROGRAM&gt;_ACTIVE_HELP where &lt;PROGRAM&gt; is the name of the
// root command in upper case, with all non-ASCII-alphanumeric characters replaced by `_`.
func activeHelpEnvVar(name string) string <span class="cov8" title="1">{
        return configEnvVar(name, activeHelpEnvVarSuffix)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "fmt"
        "strings"
)

type PositionalArgs func(cmd *Command, args []string) error

// legacyArgs validation has the following behaviour:
// - root commands with no subcommands can take arbitrary arguments
// - root commands with subcommands will do subcommand validity checking
// - subcommands will always accept arbitrary arguments
func legacyArgs(cmd *Command, args []string) error <span class="cov8" title="1">{
        // no subcommand, always take args
        if !cmd.HasSubCommands() </span><span class="cov8" title="1">{
                return nil
        }</span>

        // root command with subcommands, do subcommand checking.
        <span class="cov8" title="1">if !cmd.HasParent() &amp;&amp; len(args) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("unknown command %q for %q%s", args[0], cmd.CommandPath(), cmd.findSuggestions(args[0]))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NoArgs returns an error if any args are included.
func NoArgs(cmd *Command, args []string) error <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("unknown command %q for %q", args[0], cmd.CommandPath())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// OnlyValidArgs returns an error if there are any positional args that are not in
// the `ValidArgs` field of `Command`
func OnlyValidArgs(cmd *Command, args []string) error <span class="cov8" title="1">{
        if len(cmd.ValidArgs) &gt; 0 </span><span class="cov8" title="1">{
                // Remove any description that may be included in ValidArgs.
                // A description is following a tab character.
                validArgs := make([]string, 0, len(cmd.ValidArgs))
                for _, v := range cmd.ValidArgs </span><span class="cov8" title="1">{
                        validArgs = append(validArgs, strings.SplitN(v, "\t", 2)[0])
                }</span>
                <span class="cov8" title="1">for _, v := range args </span><span class="cov8" title="1">{
                        if !stringInSlice(v, validArgs) </span><span class="cov8" title="1">{
                                return fmt.Errorf("invalid argument %q for %q%s", v, cmd.CommandPath(), cmd.findSuggestions(args[0]))
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ArbitraryArgs never returns an error.
func ArbitraryArgs(cmd *Command, args []string) error <span class="cov8" title="1">{
        return nil
}</span>

// MinimumNArgs returns an error if there is not at least N args.
func MinimumNArgs(n int) PositionalArgs <span class="cov8" title="1">{
        return func(cmd *Command, args []string) error </span><span class="cov8" title="1">{
                if len(args) &lt; n </span><span class="cov8" title="1">{
                        return fmt.Errorf("requires at least %d arg(s), only received %d", n, len(args))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// MaximumNArgs returns an error if there are more than N args.
func MaximumNArgs(n int) PositionalArgs <span class="cov8" title="1">{
        return func(cmd *Command, args []string) error </span><span class="cov8" title="1">{
                if len(args) &gt; n </span><span class="cov8" title="1">{
                        return fmt.Errorf("accepts at most %d arg(s), received %d", n, len(args))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// ExactArgs returns an error if there are not exactly n args.
func ExactArgs(n int) PositionalArgs <span class="cov8" title="1">{
        return func(cmd *Command, args []string) error </span><span class="cov8" title="1">{
                if len(args) != n </span><span class="cov8" title="1">{
                        return fmt.Errorf("accepts %d arg(s), received %d", n, len(args))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// RangeArgs returns an error if the number of args is not within the expected range.
func RangeArgs(min int, max int) PositionalArgs <span class="cov8" title="1">{
        return func(cmd *Command, args []string) error </span><span class="cov8" title="1">{
                if len(args) &lt; min || len(args) &gt; max </span><span class="cov8" title="1">{
                        return fmt.Errorf("accepts between %d and %d arg(s), received %d", min, max, len(args))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// MatchAll allows combining several PositionalArgs to work in concert.
func MatchAll(pargs ...PositionalArgs) PositionalArgs <span class="cov8" title="1">{
        return func(cmd *Command, args []string) error </span><span class="cov8" title="1">{
                for _, parg := range pargs </span><span class="cov8" title="1">{
                        if err := parg(cmd, args); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
}

// ExactValidArgs returns an error if there are not exactly N positional args OR
// there are any positional args that are not in the `ValidArgs` field of `Command`
//
// Deprecated: use MatchAll(ExactArgs(n), OnlyValidArgs) instead
func ExactValidArgs(n int) PositionalArgs <span class="cov8" title="1">{
        return MatchAll(ExactArgs(n), OnlyValidArgs)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "sort"
        "strings"

        "github.com/spf13/pflag"
)

// Annotations for Bash completion.
const (
        BashCompFilenameExt     = "cobra_annotation_bash_completion_filename_extensions"
        BashCompCustom          = "cobra_annotation_bash_completion_custom"
        BashCompOneRequiredFlag = "cobra_annotation_bash_completion_one_required_flag"
        BashCompSubdirsInDir    = "cobra_annotation_bash_completion_subdirs_in_dir"
)

func writePreamble(buf io.StringWriter, name string) <span class="cov8" title="1">{
        WriteStringAndCheck(buf, fmt.Sprintf("# bash completion for %-36s -*- shell-script -*-\n", name))
        WriteStringAndCheck(buf, fmt.Sprintf(`
__%[1]s_debug()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE:-} ]]; then
        echo "$*" &gt;&gt; "${BASH_COMP_DEBUG_FILE}"
    fi
}

# Homebrew on Macs have version 1.3 of bash-completion which doesn't include
# _init_completion. This is a very minimal version of that function.
__%[1]s_init_completion()
{
    COMPREPLY=()
    _get_comp_words_by_ref "$@" cur prev words cword
}

__%[1]s_index_of_word()
{
    local w word=$1
    shift
    index=0
    for w in "$@"; do
        [[ $w = "$word" ]] &amp;&amp; return
        index=$((index+1))
    done
    index=-1
}

__%[1]s_contains_word()
{
    local w word=$1; shift
    for w in "$@"; do
        [[ $w = "$word" ]] &amp;&amp; return
    done
    return 1
}

__%[1]s_handle_go_custom_completion()
{
    __%[1]s_debug "${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}"

    local shellCompDirectiveError=%[3]d
    local shellCompDirectiveNoSpace=%[4]d
    local shellCompDirectiveNoFileComp=%[5]d
    local shellCompDirectiveFilterFileExt=%[6]d
    local shellCompDirectiveFilterDirs=%[7]d

    local out requestComp lastParam lastChar comp directive args

    # Prepare the command to request completions for the program.
    # Calling ${words[0]} instead of directly %[1]s allows handling aliases
    args=("${words[@]:1}")
    # Disable ActiveHelp which is not supported for bash completion v1
    requestComp="%[8]s=0 ${words[0]} %[2]s ${args[*]}"

    lastParam=${words[$((${#words[@]}-1))]}
    lastChar=${lastParam:$((${#lastParam}-1)):1}
    __%[1]s_debug "${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}"

    if [ -z "${cur}" ] &amp;&amp; [ "${lastChar}" != "=" ]; then
        # If the last parameter is complete (there is a space following it)
        # We add an extra empty parameter so we can indicate this to the go method.
        __%[1]s_debug "${FUNCNAME[0]}: Adding extra empty parameter"
        requestComp="${requestComp} \"\""
    fi

    __%[1]s_debug "${FUNCNAME[0]}: calling ${requestComp}"
    # Use eval to handle any environment variables and such
    out=$(eval "${requestComp}" 2&gt;/dev/null)

    # Extract the directive integer at the very end of the output following a colon (:)
    directive=${out##*:}
    # Remove the directive
    out=${out%%:*}
    if [ "${directive}" = "${out}" ]; then
        # There is not directive specified
        directive=0
    fi
    __%[1]s_debug "${FUNCNAME[0]}: the completion directive is: ${directive}"
    __%[1]s_debug "${FUNCNAME[0]}: the completions are: ${out}"

    if [ $((directive &amp; shellCompDirectiveError)) -ne 0 ]; then
        # Error code.  No completion.
        __%[1]s_debug "${FUNCNAME[0]}: received error from custom completion go code"
        return
    else
        if [ $((directive &amp; shellCompDirectiveNoSpace)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __%[1]s_debug "${FUNCNAME[0]}: activating no space"
                compopt -o nospace
            fi
        fi
        if [ $((directive &amp; shellCompDirectiveNoFileComp)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __%[1]s_debug "${FUNCNAME[0]}: activating no file completion"
                compopt +o default
            fi
        fi
    fi

    if [ $((directive &amp; shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        # File extension filtering
        local fullFilter filter filteringCmd
        # Do not use quotes around the $out variable or else newline
        # characters will be kept.
        for filter in ${out}; do
            fullFilter+="$filter|"
        done

        filteringCmd="_filedir $fullFilter"
        __%[1]s_debug "File filtering command: $filteringCmd"
        $filteringCmd
    elif [ $((directive &amp; shellCompDirectiveFilterDirs)) -ne 0 ]; then
        # File completion for directories only
        local subdir
        # Use printf to strip any trailing newline
        subdir=$(printf "%%s" "${out}")
        if [ -n "$subdir" ]; then
            __%[1]s_debug "Listing directories in $subdir"
            __%[1]s_handle_subdirs_in_dir_flag "$subdir"
        else
            __%[1]s_debug "Listing directories in ."
            _filedir -d
        fi
    else
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp")
        done &lt; &lt;(compgen -W "${out}" -- "$cur")
    fi
}

__%[1]s_handle_reply()
{
    __%[1]s_debug "${FUNCNAME[0]}"
    local comp
    case $cur in
        -*)
            if [[ $(type -t compopt) = "builtin" ]]; then
                compopt -o nospace
            fi
            local allflags
            if [ ${#must_have_one_flag[@]} -ne 0 ]; then
                allflags=("${must_have_one_flag[@]}")
            else
                allflags=("${flags[*]} ${two_word_flags[*]}")
            fi
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp")
            done &lt; &lt;(compgen -W "${allflags[*]}" -- "$cur")
            if [[ $(type -t compopt) = "builtin" ]]; then
                [[ "${COMPREPLY[0]}" == *= ]] || compopt +o nospace
            fi

            # complete after --flag=abc
            if [[ $cur == *=* ]]; then
                if [[ $(type -t compopt) = "builtin" ]]; then
                    compopt +o nospace
                fi

                local index flag
                flag="${cur%%=*}"
                __%[1]s_index_of_word "${flag}" "${flags_with_completion[@]}"
                COMPREPLY=()
                if [[ ${index} -ge 0 ]]; then
                    PREFIX=""
                    cur="${cur#*=}"
                    ${flags_completion[${index}]}
                    if [ -n "${ZSH_VERSION:-}" ]; then
                        # zsh completion needs --flag= prefix
                        eval "COMPREPLY=( \"\${COMPREPLY[@]/#/${flag}=}\" )"
                    fi
                fi
            fi

            if [[ -z "${flag_parsing_disabled}" ]]; then
                # If flag parsing is enabled, we have completed the flags and can return.
                # If flag parsing is disabled, we may not know all (or any) of the flags, so we fallthrough
                # to possibly call handle_go_custom_completion.
                return 0;
            fi
            ;;
    esac

    # check if we are handling a flag with special work handling
    local index
    __%[1]s_index_of_word "${prev}" "${flags_with_completion[@]}"
    if [[ ${index} -ge 0 ]]; then
        ${flags_completion[${index}]}
        return
    fi

    # we are parsing a flag and don't have a special handler, no completion
    if [[ ${cur} != "${words[cword]}" ]]; then
        return
    fi

    local completions
    completions=("${commands[@]}")
    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then
        completions+=("${must_have_one_noun[@]}")
    elif [[ -n "${has_completion_function}" ]]; then
        # if a go completion function is provided, defer to that function
        __%[1]s_handle_go_custom_completion
    fi
    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then
        completions+=("${must_have_one_flag[@]}")
    fi
    while IFS='' read -r comp; do
        COMPREPLY+=("$comp")
    done &lt; &lt;(compgen -W "${completions[*]}" -- "$cur")

    if [[ ${#COMPREPLY[@]} -eq 0 &amp;&amp; ${#noun_aliases[@]} -gt 0 &amp;&amp; ${#must_have_one_noun[@]} -ne 0 ]]; then
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp")
        done &lt; &lt;(compgen -W "${noun_aliases[*]}" -- "$cur")
    fi

    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        if declare -F __%[1]s_custom_func &gt;/dev/null; then
            # try command name qualified custom func
            __%[1]s_custom_func
        else
            # otherwise fall back to unqualified for compatibility
            declare -F __custom_func &gt;/dev/null &amp;&amp; __custom_func
        fi
    fi

    # available in bash-completion &gt;= 2, not always present on macOS
    if declare -F __ltrim_colon_completions &gt;/dev/null; then
        __ltrim_colon_completions "$cur"
    fi

    # If there is only 1 completion and it is a flag with an = it will be completed
    # but we don't want a space after the =
    if [[ "${#COMPREPLY[@]}" -eq "1" ]] &amp;&amp; [[ $(type -t compopt) = "builtin" ]] &amp;&amp; [[ "${COMPREPLY[0]}" == --*= ]]; then
       compopt -o nospace
    fi
}

# The arguments should be in the form "ext1|ext2|extn"
__%[1]s_handle_filename_extension_flag()
{
    local ext="$1"
    _filedir "@(${ext})"
}

__%[1]s_handle_subdirs_in_dir_flag()
{
    local dir="$1"
    pushd "${dir}" &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _filedir -d &amp;&amp; popd &gt;/dev/null 2&gt;&amp;1 || return
}

__%[1]s_handle_flag()
{
    __%[1]s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    # if a command required a flag, and we found it, unset must_have_one_flag()
    local flagname=${words[c]}
    local flagvalue=""
    # if the word contained an =
    if [[ ${words[c]} == *"="* ]]; then
        flagvalue=${flagname#*=} # take in as flagvalue after the =
        flagname=${flagname%%=*} # strip everything after the =
        flagname="${flagname}=" # but put the = back
    fi
    __%[1]s_debug "${FUNCNAME[0]}: looking for ${flagname}"
    if __%[1]s_contains_word "${flagname}" "${must_have_one_flag[@]}"; then
        must_have_one_flag=()
    fi

    # if you set a flag which only applies to this command, don't show subcommands
    if __%[1]s_contains_word "${flagname}" "${local_nonpersistent_flags[@]}"; then
      commands=()
    fi

    # keep flag value with flagname as flaghash
    # flaghash variable is an associative array which is only supported in bash &gt; 3.
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        if [ -n "${flagvalue}" ] ; then
            flaghash[${flagname}]=${flagvalue}
        elif [ -n "${words[ $((c+1)) ]}" ] ; then
            flaghash[${flagname}]=${words[ $((c+1)) ]}
        else
            flaghash[${flagname}]="true" # pad "true" for bool flag
        fi
    fi

    # skip the argument to a two word flag
    if [[ ${words[c]} != *"="* ]] &amp;&amp; __%[1]s_contains_word "${words[c]}" "${two_word_flags[@]}"; then
        __%[1]s_debug "${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument"
        c=$((c+1))
        # if we are looking for a flags value, don't show commands
        if [[ $c -eq $cword ]]; then
            commands=()
        fi
    fi

    c=$((c+1))

}

__%[1]s_handle_noun()
{
    __%[1]s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    if __%[1]s_contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
        must_have_one_noun=()
    elif __%[1]s_contains_word "${words[c]}" "${noun_aliases[@]}"; then
        must_have_one_noun=()
    fi

    nouns+=("${words[c]}")
    c=$((c+1))
}

__%[1]s_handle_command()
{
    __%[1]s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    local next_command
    if [[ -n ${last_command} ]]; then
        next_command="_${last_command}_${words[c]//:/__}"
    else
        if [[ $c -eq 0 ]]; then
            next_command="_%[1]s_root_command"
        else
            next_command="_${words[c]//:/__}"
        fi
    fi
    c=$((c+1))
    __%[1]s_debug "${FUNCNAME[0]}: looking for ${next_command}"
    declare -F "$next_command" &gt;/dev/null &amp;&amp; $next_command
}

__%[1]s_handle_word()
{
    if [[ $c -ge $cword ]]; then
        __%[1]s_handle_reply
        return
    fi
    __%[1]s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"
    if [[ "${words[c]}" == -* ]]; then
        __%[1]s_handle_flag
    elif __%[1]s_contains_word "${words[c]}" "${commands[@]}"; then
        __%[1]s_handle_command
    elif [[ $c -eq 0 ]]; then
        __%[1]s_handle_command
    elif __%[1]s_contains_word "${words[c]}" "${command_aliases[@]}"; then
        # aliashash variable is an associative array which is only supported in bash &gt; 3.
        if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
            words[c]=${aliashash[${words[c]}]}
            __%[1]s_handle_command
        else
            __%[1]s_handle_noun
        fi
    else
        __%[1]s_handle_noun
    fi
    __%[1]s_handle_word
}

`, name, ShellCompNoDescRequestCmd,
                ShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,
                ShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, activeHelpEnvVar(name)))
}</span>

func writePostscript(buf io.StringWriter, name string) <span class="cov8" title="1">{
        name = strings.ReplaceAll(name, ":", "__")
        WriteStringAndCheck(buf, fmt.Sprintf("__start_%s()\n", name))
        WriteStringAndCheck(buf, fmt.Sprintf(`{
    local cur prev words cword split
    declare -A flaghash 2&gt;/dev/null || :
    declare -A aliashash 2&gt;/dev/null || :
    if declare -F _init_completion &gt;/dev/null 2&gt;&amp;1; then
        _init_completion -s || return
    else
        __%[1]s_init_completion -n "=" || return
    fi

    local c=0
    local flag_parsing_disabled=
    local flags=()
    local two_word_flags=()
    local local_nonpersistent_flags=()
    local flags_with_completion=()
    local flags_completion=()
    local commands=("%[1]s")
    local command_aliases=()
    local must_have_one_flag=()
    local must_have_one_noun=()
    local has_completion_function=""
    local last_command=""
    local nouns=()
    local noun_aliases=()

    __%[1]s_handle_word
}

`, name))
        WriteStringAndCheck(buf, fmt.Sprintf(`if [[ $(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_%s %s
else
    complete -o default -o nospace -F __start_%s %s
fi

`, name, name, name, name))
        WriteStringAndCheck(buf, "# ex: ts=4 sw=4 et filetype=sh\n")
}</span>

func writeCommands(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        WriteStringAndCheck(buf, "    commands=()\n")
        for _, c := range cmd.Commands() </span><span class="cov8" title="1">{
                if !c.IsAvailableCommand() &amp;&amp; c != cmd.helpCommand </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf("    commands+=(%q)\n", c.Name()))
                writeCmdAliases(buf, c)</span>
        }
        <span class="cov8" title="1">WriteStringAndCheck(buf, "\n")</span>
}

func writeFlagHandler(buf io.StringWriter, name string, annotations map[string][]string, cmd *Command) <span class="cov8" title="1">{
        for key, value := range annotations </span><span class="cov8" title="1">{
                switch key </span>{
                case BashCompFilenameExt:<span class="cov8" title="1">
                        WriteStringAndCheck(buf, fmt.Sprintf("    flags_with_completion+=(%q)\n", name))

                        var ext string
                        if len(value) &gt; 0 </span><span class="cov8" title="1">{
                                ext = fmt.Sprintf("__%s_handle_filename_extension_flag ", cmd.Root().Name()) + strings.Join(value, "|")
                        }</span> else<span class="cov8" title="1"> {
                                ext = "_filedir"
                        }</span>
                        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf("    flags_completion+=(%q)\n", ext))</span>
                case BashCompCustom:<span class="cov8" title="1">
                        WriteStringAndCheck(buf, fmt.Sprintf("    flags_with_completion+=(%q)\n", name))

                        if len(value) &gt; 0 </span><span class="cov8" title="1">{
                                handlers := strings.Join(value, "; ")
                                WriteStringAndCheck(buf, fmt.Sprintf("    flags_completion+=(%q)\n", handlers))
                        }</span> else<span class="cov0" title="0"> {
                                WriteStringAndCheck(buf, "    flags_completion+=(:)\n")
                        }</span>
                case BashCompSubdirsInDir:<span class="cov8" title="1">
                        WriteStringAndCheck(buf, fmt.Sprintf("    flags_with_completion+=(%q)\n", name))

                        var ext string
                        if len(value) == 1 </span><span class="cov8" title="1">{
                                ext = fmt.Sprintf("__%s_handle_subdirs_in_dir_flag ", cmd.Root().Name()) + value[0]
                        }</span> else<span class="cov0" title="0"> {
                                ext = "_filedir -d"
                        }</span>
                        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf("    flags_completion+=(%q)\n", ext))</span>
                }
        }
}

const cbn = "\")\n"

func writeShortFlag(buf io.StringWriter, flag *pflag.Flag, cmd *Command) <span class="cov8" title="1">{
        name := flag.Shorthand
        format := "    "
        if len(flag.NoOptDefVal) == 0 </span><span class="cov8" title="1">{
                format += "two_word_"
        }</span>
        <span class="cov8" title="1">format += "flags+=(\"-%s" + cbn
        WriteStringAndCheck(buf, fmt.Sprintf(format, name))
        writeFlagHandler(buf, "-"+name, flag.Annotations, cmd)</span>
}

func writeFlag(buf io.StringWriter, flag *pflag.Flag, cmd *Command) <span class="cov8" title="1">{
        name := flag.Name
        format := "    flags+=(\"--%s"
        if len(flag.NoOptDefVal) == 0 </span><span class="cov8" title="1">{
                format += "="
        }</span>
        <span class="cov8" title="1">format += cbn
        WriteStringAndCheck(buf, fmt.Sprintf(format, name))
        if len(flag.NoOptDefVal) == 0 </span><span class="cov8" title="1">{
                format = "    two_word_flags+=(\"--%s" + cbn
                WriteStringAndCheck(buf, fmt.Sprintf(format, name))
        }</span>
        <span class="cov8" title="1">writeFlagHandler(buf, "--"+name, flag.Annotations, cmd)</span>
}

func writeLocalNonPersistentFlag(buf io.StringWriter, flag *pflag.Flag) <span class="cov8" title="1">{
        name := flag.Name
        format := "    local_nonpersistent_flags+=(\"--%[1]s" + cbn
        if len(flag.NoOptDefVal) == 0 </span><span class="cov8" title="1">{
                format += "    local_nonpersistent_flags+=(\"--%[1]s=" + cbn
        }</span>
        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf(format, name))
        if len(flag.Shorthand) &gt; 0 </span><span class="cov8" title="1">{
                WriteStringAndCheck(buf, fmt.Sprintf("    local_nonpersistent_flags+=(\"-%s\")\n", flag.Shorthand))
        }</span>
}

// prepareCustomAnnotationsForFlags setup annotations for go completions for registered flags
func prepareCustomAnnotationsForFlags(cmd *Command) <span class="cov8" title="1">{
        flagCompletionMutex.RLock()
        defer flagCompletionMutex.RUnlock()
        for flag := range flagCompletionFunctions </span><span class="cov8" title="1">{
                // Make sure the completion script calls the __*_go_custom_completion function for
                // every registered flag.  We need to do this here (and not when the flag was registered
                // for completion) so that we can know the root command name for the prefix
                // of __&lt;prefix&gt;_go_custom_completion
                if flag.Annotations == nil </span><span class="cov8" title="1">{
                        flag.Annotations = map[string][]string{}
                }</span>
                <span class="cov8" title="1">flag.Annotations[BashCompCustom] = []string{fmt.Sprintf("__%[1]s_handle_go_custom_completion", cmd.Root().Name())}</span>
        }
}

func writeFlags(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        prepareCustomAnnotationsForFlags(cmd)
        WriteStringAndCheck(buf, `    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

`)

        if cmd.DisableFlagParsing </span><span class="cov0" title="0">{
                WriteStringAndCheck(buf, "    flag_parsing_disabled=1\n")
        }</span>

        <span class="cov8" title="1">localNonPersistentFlags := cmd.LocalNonPersistentFlags()
        cmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                if nonCompletableFlag(flag) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">writeFlag(buf, flag, cmd)
                if len(flag.Shorthand) &gt; 0 </span><span class="cov8" title="1">{
                        writeShortFlag(buf, flag, cmd)
                }</span>
                // localNonPersistentFlags are used to stop the completion of subcommands when one is set
                // if TraverseChildren is true we should allow to complete subcommands
                <span class="cov8" title="1">if localNonPersistentFlags.Lookup(flag.Name) != nil &amp;&amp; !cmd.Root().TraverseChildren </span><span class="cov8" title="1">{
                        writeLocalNonPersistentFlag(buf, flag)
                }</span>
        })
        <span class="cov8" title="1">cmd.InheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                if nonCompletableFlag(flag) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">writeFlag(buf, flag, cmd)
                if len(flag.Shorthand) &gt; 0 </span><span class="cov0" title="0">{
                        writeShortFlag(buf, flag, cmd)
                }</span>
        })

        <span class="cov8" title="1">WriteStringAndCheck(buf, "\n")</span>
}

func writeRequiredFlag(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        WriteStringAndCheck(buf, "    must_have_one_flag=()\n")
        flags := cmd.NonInheritedFlags()
        flags.VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                if nonCompletableFlag(flag) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if _, ok := flag.Annotations[BashCompOneRequiredFlag]; ok </span><span class="cov8" title="1">{
                        format := "    must_have_one_flag+=(\"--%s"
                        if flag.Value.Type() != "bool" </span><span class="cov8" title="1">{
                                format += "="
                        }</span>
                        <span class="cov8" title="1">format += cbn
                        WriteStringAndCheck(buf, fmt.Sprintf(format, flag.Name))

                        if len(flag.Shorthand) &gt; 0 </span><span class="cov8" title="1">{
                                WriteStringAndCheck(buf, fmt.Sprintf("    must_have_one_flag+=(\"-%s"+cbn, flag.Shorthand))
                        }</span>
                }
        })
}

func writeRequiredNouns(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        WriteStringAndCheck(buf, "    must_have_one_noun=()\n")
        sort.Strings(cmd.ValidArgs)
        for _, value := range cmd.ValidArgs </span><span class="cov8" title="1">{
                // Remove any description that may be included following a tab character.
                // Descriptions are not supported by bash completion.
                value = strings.SplitN(value, "\t", 2)[0]
                WriteStringAndCheck(buf, fmt.Sprintf("    must_have_one_noun+=(%q)\n", value))
        }</span>
        <span class="cov8" title="1">if cmd.ValidArgsFunction != nil </span><span class="cov8" title="1">{
                WriteStringAndCheck(buf, "    has_completion_function=1\n")
        }</span>
}

func writeCmdAliases(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        if len(cmd.Aliases) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">sort.Strings(cmd.Aliases)

        WriteStringAndCheck(buf, fmt.Sprint(`    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then`, "\n"))
        for _, value := range cmd.Aliases </span><span class="cov8" title="1">{
                WriteStringAndCheck(buf, fmt.Sprintf("        command_aliases+=(%q)\n", value))
                WriteStringAndCheck(buf, fmt.Sprintf("        aliashash[%q]=%q\n", value, cmd.Name()))
        }</span>
        <span class="cov8" title="1">WriteStringAndCheck(buf, `    fi`)
        WriteStringAndCheck(buf, "\n")</span>
}
func writeArgAliases(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        WriteStringAndCheck(buf, "    noun_aliases=()\n")
        sort.Strings(cmd.ArgAliases)
        for _, value := range cmd.ArgAliases </span><span class="cov8" title="1">{
                WriteStringAndCheck(buf, fmt.Sprintf("    noun_aliases+=(%q)\n", value))
        }</span>
}

func gen(buf io.StringWriter, cmd *Command) <span class="cov8" title="1">{
        for _, c := range cmd.Commands() </span><span class="cov8" title="1">{
                if !c.IsAvailableCommand() &amp;&amp; c != cmd.helpCommand </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">gen(buf, c)</span>
        }
        <span class="cov8" title="1">commandName := cmd.CommandPath()
        commandName = strings.ReplaceAll(commandName, " ", "_")
        commandName = strings.ReplaceAll(commandName, ":", "__")

        if cmd.Root() == cmd </span><span class="cov8" title="1">{
                WriteStringAndCheck(buf, fmt.Sprintf("_%s_root_command()\n{\n", commandName))
        }</span> else<span class="cov8" title="1"> {
                WriteStringAndCheck(buf, fmt.Sprintf("_%s()\n{\n", commandName))
        }</span>

        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf("    last_command=%q\n", commandName))
        WriteStringAndCheck(buf, "\n")
        WriteStringAndCheck(buf, "    command_aliases=()\n")
        WriteStringAndCheck(buf, "\n")

        writeCommands(buf, cmd)
        writeFlags(buf, cmd)
        writeRequiredFlag(buf, cmd)
        writeRequiredNouns(buf, cmd)
        writeArgAliases(buf, cmd)
        WriteStringAndCheck(buf, "}\n\n")</span>
}

// GenBashCompletion generates bash completion file and writes to the passed writer.
func (c *Command) GenBashCompletion(w io.Writer) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        writePreamble(buf, c.Name())
        if len(c.BashCompletionFunction) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(c.BashCompletionFunction + "\n")
        }</span>
        <span class="cov8" title="1">gen(buf, c)
        writePostscript(buf, c.Name())

        _, err := buf.WriteTo(w)
        return err</span>
}

func nonCompletableFlag(flag *pflag.Flag) bool <span class="cov8" title="1">{
        return flag.Hidden || len(flag.Deprecated) &gt; 0
}</span>

// GenBashCompletionFile generates bash completion file.
func (c *Command) GenBashCompletionFile(filename string) error <span class="cov0" title="0">{
        outFile, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        return c.GenBashCompletion(outFile)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "bytes"
        "fmt"
        "io"
        "os"
)

func (c *Command) genBashCompletion(w io.Writer, includeDesc bool) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        genBashComp(buf, c.Name(), includeDesc)
        _, err := buf.WriteTo(w)
        return err
}</span>

func genBashComp(buf io.StringWriter, name string, includeDesc bool) <span class="cov8" title="1">{
        compCmd := ShellCompRequestCmd
        if !includeDesc </span><span class="cov0" title="0">{
                compCmd = ShellCompNoDescRequestCmd
        }</span>

        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf(`# bash completion V2 for %-36[1]s -*- shell-script -*-

__%[1]s_debug()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE-} ]]; then
        echo "$*" &gt;&gt; "${BASH_COMP_DEBUG_FILE}"
    fi
}

# Macs have bash3 for which the bash-completion package doesn't include
# _init_completion. This is a minimal version of that function.
__%[1]s_init_completion()
{
    COMPREPLY=()
    _get_comp_words_by_ref "$@" cur prev words cword
}

# This function calls the %[1]s program to obtain the completion
# results and the directive.  It fills the 'out' and 'directive' vars.
__%[1]s_get_completion_results() {
    local requestComp lastParam lastChar args

    # Prepare the command to request completions for the program.
    # Calling ${words[0]} instead of directly %[1]s allows handling aliases
    args=("${words[@]:1}")
    requestComp="${words[0]} %[2]s ${args[*]}"

    lastParam=${words[$((${#words[@]}-1))]}
    lastChar=${lastParam:$((${#lastParam}-1)):1}
    __%[1]s_debug "lastParam ${lastParam}, lastChar ${lastChar}"

    if [[ -z ${cur} &amp;&amp; ${lastChar} != = ]]; then
        # If the last parameter is complete (there is a space following it)
        # We add an extra empty parameter so we can indicate this to the go method.
        __%[1]s_debug "Adding extra empty parameter"
        requestComp="${requestComp} ''"
    fi

    # When completing a flag with an = (e.g., %[1]s -n=&lt;TAB&gt;)
    # bash focuses on the part after the =, so we need to remove
    # the flag part from $cur
    if [[ ${cur} == -*=* ]]; then
        cur="${cur#*=}"
    fi

    __%[1]s_debug "Calling ${requestComp}"
    # Use eval to handle any environment variables and such
    out=$(eval "${requestComp}" 2&gt;/dev/null)

    # Extract the directive integer at the very end of the output following a colon (:)
    directive=${out##*:}
    # Remove the directive
    out=${out%%:*}
    if [[ ${directive} == "${out}" ]]; then
        # There is not directive specified
        directive=0
    fi
    __%[1]s_debug "The completion directive is: ${directive}"
    __%[1]s_debug "The completions are: ${out}"
}

__%[1]s_process_completion_results() {
    local shellCompDirectiveError=%[3]d
    local shellCompDirectiveNoSpace=%[4]d
    local shellCompDirectiveNoFileComp=%[5]d
    local shellCompDirectiveFilterFileExt=%[6]d
    local shellCompDirectiveFilterDirs=%[7]d
    local shellCompDirectiveKeepOrder=%[8]d

    if (((directive &amp; shellCompDirectiveError) != 0)); then
        # Error code.  No completion.
        __%[1]s_debug "Received error from custom completion go code"
        return
    else
        if (((directive &amp; shellCompDirectiveNoSpace) != 0)); then
            if [[ $(type -t compopt) == builtin ]]; then
                __%[1]s_debug "Activating no space"
                compopt -o nospace
            else
                __%[1]s_debug "No space directive not supported in this version of bash"
            fi
        fi
        if (((directive &amp; shellCompDirectiveKeepOrder) != 0)); then
            if [[ $(type -t compopt) == builtin ]]; then
                # no sort isn't supported for bash less than &lt; 4.4
                if [[ ${BASH_VERSINFO[0]} -lt 4 || ( ${BASH_VERSINFO[0]} -eq 4 &amp;&amp; ${BASH_VERSINFO[1]} -lt 4 ) ]]; then
                    __%[1]s_debug "No sort directive not supported in this version of bash"
                else
                    __%[1]s_debug "Activating keep order"
                    compopt -o nosort
                fi
            else
                __%[1]s_debug "No sort directive not supported in this version of bash"
            fi
        fi
        if (((directive &amp; shellCompDirectiveNoFileComp) != 0)); then
            if [[ $(type -t compopt) == builtin ]]; then
                __%[1]s_debug "Activating no file completion"
                compopt +o default
            else
                __%[1]s_debug "No file completion directive not supported in this version of bash"
            fi
        fi
    fi

    # Separate activeHelp from normal completions
    local completions=()
    local activeHelp=()
    __%[1]s_extract_activeHelp

    if (((directive &amp; shellCompDirectiveFilterFileExt) != 0)); then
        # File extension filtering
        local fullFilter filter filteringCmd

        # Do not use quotes around the $completions variable or else newline
        # characters will be kept.
        for filter in ${completions[*]}; do
            fullFilter+="$filter|"
        done

        filteringCmd="_filedir $fullFilter"
        __%[1]s_debug "File filtering command: $filteringCmd"
        $filteringCmd
    elif (((directive &amp; shellCompDirectiveFilterDirs) != 0)); then
        # File completion for directories only

        local subdir
        subdir=${completions[0]}
        if [[ -n $subdir ]]; then
            __%[1]s_debug "Listing directories in $subdir"
            pushd "$subdir" &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _filedir -d &amp;&amp; popd &gt;/dev/null 2&gt;&amp;1 || return
        else
            __%[1]s_debug "Listing directories in ."
            _filedir -d
        fi
    else
        __%[1]s_handle_completion_types
    fi

    __%[1]s_handle_special_char "$cur" :
    __%[1]s_handle_special_char "$cur" =

    # Print the activeHelp statements before we finish
    if ((${#activeHelp[*]} != 0)); then
        printf "\n";
        printf "%%s\n" "${activeHelp[@]}"
        printf "\n"

        # The prompt format is only available from bash 4.4.
        # We test if it is available before using it.
        if (x=${PS1@P}) 2&gt; /dev/null; then
            printf "%%s" "${PS1@P}${COMP_LINE[@]}"
        else
            # Can't print the prompt.  Just print the
            # text the user had typed, it is workable enough.
            printf "%%s" "${COMP_LINE[@]}"
        fi
    fi
}

# Separate activeHelp lines from real completions.
# Fills the $activeHelp and $completions arrays.
__%[1]s_extract_activeHelp() {
    local activeHelpMarker="%[9]s"
    local endIndex=${#activeHelpMarker}

    while IFS='' read -r comp; do
        if [[ ${comp:0:endIndex} == $activeHelpMarker ]]; then
            comp=${comp:endIndex}
            __%[1]s_debug "ActiveHelp found: $comp"
            if [[ -n $comp ]]; then
                activeHelp+=("$comp")
            fi
        else
            # Not an activeHelp line but a normal completion
            completions+=("$comp")
        fi
    done &lt;&lt;&lt;"${out}"
}

__%[1]s_handle_completion_types() {
    __%[1]s_debug "__%[1]s_handle_completion_types: COMP_TYPE is $COMP_TYPE"

    case $COMP_TYPE in
    37|42)
        # Type: menu-complete/menu-complete-backward and insert-completions
        # If the user requested inserting one completion at a time, or all
        # completions at once on the command-line we must remove the descriptions.
        # https://github.com/spf13/cobra/issues/1508
        local tab=$'\t' comp
        while IFS='' read -r comp; do
            [[ -z $comp ]] &amp;&amp; continue
            # Strip any description
            comp=${comp%%%%$tab*}
            # Only consider the completions that match
            if [[ $comp == "$cur"* ]]; then
                COMPREPLY+=("$comp")
            fi
        done &lt; &lt;(printf "%%s\n" "${completions[@]}")
        ;;

    *)
        # Type: complete (normal completion)
        __%[1]s_handle_standard_completion_case
        ;;
    esac
}

__%[1]s_handle_standard_completion_case() {
    local tab=$'\t' comp

    # Short circuit to optimize if we don't have descriptions
    if [[ "${completions[*]}" != *$tab* ]]; then
        IFS=$'\n' read -ra COMPREPLY -d '' &lt; &lt;(compgen -W "${completions[*]}" -- "$cur")
        return 0
    fi

    local longest=0
    local compline
    # Look for the longest completion so that we can format things nicely
    while IFS='' read -r compline; do
        [[ -z $compline ]] &amp;&amp; continue
        # Strip any description before checking the length
        comp=${compline%%%%$tab*}
        # Only consider the completions that match
        [[ $comp == "$cur"* ]] || continue
        COMPREPLY+=("$compline")
        if ((${#comp}&gt;longest)); then
            longest=${#comp}
        fi
    done &lt; &lt;(printf "%%s\n" "${completions[@]}")

    # If there is a single completion left, remove the description text
    if ((${#COMPREPLY[*]} == 1)); then
        __%[1]s_debug "COMPREPLY[0]: ${COMPREPLY[0]}"
        comp="${COMPREPLY[0]%%%%$tab*}"
        __%[1]s_debug "Removed description from single completion, which is now: ${comp}"
        COMPREPLY[0]=$comp
    else # Format the descriptions
        __%[1]s_format_comp_descriptions $longest
    fi
}

__%[1]s_handle_special_char()
{
    local comp="$1"
    local char=$2
    if [[ "$comp" == *${char}* &amp;&amp; "$COMP_WORDBREAKS" == *${char}* ]]; then
        local word=${comp%%"${comp##*${char}}"}
        local idx=${#COMPREPLY[*]}
        while ((--idx &gt;= 0)); do
            COMPREPLY[idx]=${COMPREPLY[idx]#"$word"}
        done
    fi
}

__%[1]s_format_comp_descriptions()
{
    local tab=$'\t'
    local comp desc maxdesclength
    local longest=$1

    local i ci
    for ci in ${!COMPREPLY[*]}; do
        comp=${COMPREPLY[ci]}
        # Properly format the description string which follows a tab character if there is one
        if [[ "$comp" == *$tab* ]]; then
            __%[1]s_debug "Original comp: $comp"
            desc=${comp#*$tab}
            comp=${comp%%%%$tab*}

            # $COLUMNS stores the current shell width.
            # Remove an extra 4 because we add 2 spaces and 2 parentheses.
            maxdesclength=$(( COLUMNS - longest - 4 ))

            # Make sure we can fit a description of at least 8 characters
            # if we are to align the descriptions.
            if ((maxdesclength &gt; 8)); then
                # Add the proper number of spaces to align the descriptions
                for ((i = ${#comp} ; i &lt; longest ; i++)); do
                    comp+=" "
                done
            else
                # Don't pad the descriptions so we can fit more text after the completion
                maxdesclength=$(( COLUMNS - ${#comp} - 4 ))
            fi

            # If there is enough space for any description text,
            # truncate the descriptions that are too long for the shell width
            if ((maxdesclength &gt; 0)); then
                if ((${#desc} &gt; maxdesclength)); then
                    desc=${desc:0:$(( maxdesclength - 1 ))}
                    desc+="…"
                fi
                comp+="  ($desc)"
            fi
            COMPREPLY[ci]=$comp
            __%[1]s_debug "Final comp: $comp"
        fi
    done
}

__start_%[1]s()
{
    local cur prev words cword split

    COMPREPLY=()

    # Call _init_completion from the bash-completion package
    # to prepare the arguments properly
    if declare -F _init_completion &gt;/dev/null 2&gt;&amp;1; then
        _init_completion -n =: || return
    else
        __%[1]s_init_completion -n =: || return
    fi

    __%[1]s_debug
    __%[1]s_debug "========= starting completion logic =========="
    __%[1]s_debug "cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}, cword is $cword"

    # The user could have moved the cursor backwards on the command-line.
    # We need to trigger completion from the $cword location, so we need
    # to truncate the command-line ($words) up to the $cword location.
    words=("${words[@]:0:$cword+1}")
    __%[1]s_debug "Truncated words[*]: ${words[*]},"

    local out directive
    __%[1]s_get_completion_results
    __%[1]s_process_completion_results
}

if [[ $(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_%[1]s %[1]s
else
    complete -o default -o nospace -F __start_%[1]s %[1]s
fi

# ex: ts=4 sw=4 et filetype=sh
`, name, compCmd,
                ShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,
                ShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder,
                activeHelpMarker))</span>
}

// GenBashCompletionFileV2 generates Bash completion version 2.
func (c *Command) GenBashCompletionFileV2(filename string, includeDesc bool) error <span class="cov0" title="0">{
        outFile, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        return c.GenBashCompletionV2(outFile, includeDesc)</span>
}

// GenBashCompletionV2 generates Bash completion file version 2
// and writes it to the passed writer.
func (c *Command) GenBashCompletionV2(w io.Writer, includeDesc bool) error <span class="cov8" title="1">{
        return c.genBashCompletion(w, includeDesc)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Commands similar to git, go tools and other modern CLI tools
// inspired by go, go-Commander, gh and subcommand

package cobra

import (
        "fmt"
        "io"
        "os"
        "reflect"
        "strconv"
        "strings"

        "text/template"
        "time"
        "unicode"
)

var templateFuncs = template.FuncMap{
        "trim":                    strings.TrimSpace,
        "trimRightSpace":          trimRightSpace,
        "trimTrailingWhitespaces": trimRightSpace,
        "appendIfNotPresent":      appendIfNotPresent,
        "rpad":                    rpad,
        "gt":                      Gt,
        "eq":                      Eq,
}


var initializers []func()
var finalizers []func()

const (
        defaultPrefixMatching   = false
        defaultCommandSorting   = true
        defaultCaseInsensitive  = false
        defaultTraverseRunHooks = false
)
var osExit = os.Exit
// EnablePrefixMatching allows setting automatic prefix matching. Automatic prefix matching can be a dangerous thing
// to automatically enable in CLI tools.
// Set this to true to enable it.
var EnablePrefixMatching = defaultPrefixMatching

// EnableCommandSorting controls sorting of the slice of commands, which is turned on by default.
// To disable sorting, set it to false.
var EnableCommandSorting = defaultCommandSorting

// EnableCaseInsensitive allows case-insensitive commands names. (case sensitive by default)
var EnableCaseInsensitive = defaultCaseInsensitive

// EnableTraverseRunHooks executes persistent pre-run and post-run hooks from all parents.
// By default this is disabled, which means only the first run hook to be found is executed.
var EnableTraverseRunHooks = defaultTraverseRunHooks

// MousetrapHelpText enables an information splash screen on Windows
// if the CLI is started from explorer.exe.
// To disable the mousetrap, just set this variable to blank string ("").
// Works only on Microsoft Windows.
var MousetrapHelpText = `This is a command line tool.

You need to open cmd.exe and run it from there.
`

// MousetrapDisplayDuration controls how long the MousetrapHelpText message is displayed on Windows
// if the CLI is started from explorer.exe. Set to 0 to wait for the return key to be pressed.
// To disable the mousetrap, just set MousetrapHelpText to blank string ("").
// Works only on Microsoft Windows.
var MousetrapDisplayDuration = 5 * time.Second

// AddTemplateFunc adds a template function that's available to Usage and Help
// template generation.
func AddTemplateFunc(name string, tmplFunc interface{}) <span class="cov8" title="1">{
        templateFuncs[name] = tmplFunc
}</span>

// AddTemplateFuncs adds multiple template functions that are available to Usage and
// Help template generation.
func AddTemplateFuncs(tmplFuncs template.FuncMap) <span class="cov8" title="1">{
        for k, v := range tmplFuncs </span><span class="cov8" title="1">{
                templateFuncs[k] = v
        }</span>
}

// OnInitialize sets the passed functions to be run when each command's
// Execute method is called.
func OnInitialize(y ...func()) <span class="cov8" title="1">{
        initializers = append(initializers, y...)
}</span>

// OnFinalize sets the passed functions to be run when each command's
// Execute method is terminated.
func OnFinalize(y ...func()) <span class="cov8" title="1">{
        finalizers = append(finalizers, y...)
}</span>

// FIXME Gt is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.

// Gt takes two types and checks whether the first type is greater than the second. In case of types Arrays, Chans,
// Maps and Slices, Gt will compare their lengths. Ints are compared directly while strings are first parsed as
// ints and then compared.
func Gt(a interface{}, b interface{}) bool <span class="cov8" title="1">{
        var left, right int64
        av := reflect.ValueOf(a)

        switch av.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                left = int64(av.Len())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                left = av.Int()</span>
        case reflect.String:<span class="cov8" title="1">
                left, _ = strconv.ParseInt(av.String(), 10, 64)</span>
        }

        <span class="cov8" title="1">bv := reflect.ValueOf(b)

        switch bv.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                right = int64(bv.Len())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                right = bv.Int()</span>
        case reflect.String:<span class="cov8" title="1">
                right, _ = strconv.ParseInt(bv.String(), 10, 64)</span>
        }

        <span class="cov8" title="1">return left &gt; right</span>
}

// FIXME Eq is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.

// Eq takes two types and checks whether they are equal. Supported types are int and string. Unsupported types will panic.
func Eq(a interface{}, b interface{}) bool <span class="cov8" title="1">{
        av := reflect.ValueOf(a)
        bv := reflect.ValueOf(b)

        switch av.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                panic("Eq called on unsupported type")</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return av.Int() == bv.Int()</span>
        case reflect.String:<span class="cov8" title="1">
                return av.String() == bv.String()</span>
        }
        <span class="cov8" title="1">return false</span>
}

func trimRightSpace(s string) string <span class="cov8" title="1">{
        return strings.TrimRightFunc(s, unicode.IsSpace)
}</span>

// FIXME appendIfNotPresent is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.

// appendIfNotPresent will append stringToAppend to the end of s, but only if it's not yet present in s.
func appendIfNotPresent(s, stringToAppend string) string <span class="cov8" title="1">{
        if strings.Contains(s, stringToAppend) </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s + " " + stringToAppend</span>
}

// rpad adds padding to the right of a string.
func rpad(s string, padding int) string <span class="cov8" title="1">{
        formattedString := fmt.Sprintf("%%-%ds", padding)
        return fmt.Sprintf(formattedString, s)
}</span>

// tmpl executes the given template text on data, writing the result to w.
func tmpl(w io.Writer, text string, data interface{}) error <span class="cov8" title="1">{
        t := template.New("top")
        t.Funcs(templateFuncs)
        template.Must(t.Parse(text))
        return t.Execute(w, data)
}</span>

// ld compares two strings and returns the levenshtein distance between them.
func ld(s, t string, ignoreCase bool) int <span class="cov8" title="1">{
        if ignoreCase </span><span class="cov8" title="1">{
                s = strings.ToLower(s)
                t = strings.ToLower(t)
        }</span>
        <span class="cov8" title="1">d := make([][]int, len(s)+1)
        for i := range d </span><span class="cov8" title="1">{
                d[i] = make([]int, len(t)+1)
                d[i][0] = i
        }</span>
        <span class="cov8" title="1">for j := range d[0] </span><span class="cov8" title="1">{
                d[0][j] = j
        }</span>
        <span class="cov8" title="1">for j := 1; j &lt;= len(t); j++ </span><span class="cov8" title="1">{
                for i := 1; i &lt;= len(s); i++ </span><span class="cov8" title="1">{
                        if s[i-1] == t[j-1] </span><span class="cov8" title="1">{
                                d[i][j] = d[i-1][j-1]
                        }</span> else<span class="cov8" title="1"> {
                                min := d[i-1][j]
                                if d[i][j-1] &lt; min </span><span class="cov8" title="1">{
                                        min = d[i][j-1]
                                }</span>
                                <span class="cov8" title="1">if d[i-1][j-1] &lt; min </span><span class="cov8" title="1">{
                                        min = d[i-1][j-1]
                                }</span>
                                <span class="cov8" title="1">d[i][j] = min + 1</span>
                        }
                }

        }
        <span class="cov8" title="1">return d[len(s)][len(t)]</span>
}

func stringInSlice(a string, list []string) bool <span class="cov8" title="1">{
        for _, b := range list </span><span class="cov8" title="1">{
                if b == a </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// CheckErr prints the msg with the prefix 'Error:' and exits with error code 1. If the msg is nil, it does nothing.
func CheckErr(msg interface{}) <span class="cov8" title="1">{
        if msg != nil </span><span class="cov8" title="1">{
                fmt.Fprintln(os.Stderr, "Error:", msg)
                osExit(1)
        }</span>
}

// WriteStringAndCheck writes a string into a buffer, and checks if the error is not nil.
func WriteStringAndCheck(b io.StringWriter, s string) <span class="cov8" title="1">{
        _, err := b.WriteString(s)
        CheckErr(err)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package cobra is a commander providing a simple interface to create powerful modern CLI interfaces.
// In addition to providing an interface, Cobra simultaneously provides a controller to organize your application code.
package cobra

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"

        flag "github.com/spf13/pflag"
)

const (
        FlagSetByCobraAnnotation     = "cobra_annotation_flag_set_by_cobra"
        CommandDisplayNameAnnotation = "cobra_annotation_command_display_name"
)

// FParseErrWhitelist configures Flag parse errors to be ignored
type FParseErrWhitelist flag.ParseErrorsWhitelist

// Group Structure to manage groups for commands
type Group struct {
        ID    string
        Title string
}

// Command is just that, a command for your application.
// E.g.  'go run ...' - 'run' is the command. Cobra requires
// you to define the usage and description as part of your command
// definition to ensure usability.
type Command struct {
        // Use is the one-line usage message.
        // Recommended syntax is as follows:
        //   [ ] identifies an optional argument. Arguments that are not enclosed in brackets are required.
        //   ... indicates that you can specify multiple values for the previous argument.
        //   |   indicates mutually exclusive information. You can use the argument to the left of the separator or the
        //       argument to the right of the separator. You cannot use both arguments in a single use of the command.
        //   { } delimits a set of mutually exclusive arguments when one of the arguments is required. If the arguments are
        //       optional, they are enclosed in brackets ([ ]).
        // Example: add [-F file | -D dir]... [-f format] profile
        Use string

        // Aliases is an array of aliases that can be used instead of the first word in Use.
        Aliases []string

        // SuggestFor is an array of command names for which this command will be suggested -
        // similar to aliases but only suggests.
        SuggestFor []string

        // Short is the short description shown in the 'help' output.
        Short string

        // The group id under which this subcommand is grouped in the 'help' output of its parent.
        GroupID string

        // Long is the long message shown in the 'help &lt;this-command&gt;' output.
        Long string

        // Example is examples of how to use the command.
        Example string

        // ValidArgs is list of all valid non-flag arguments that are accepted in shell completions
        ValidArgs []string
        // ValidArgsFunction is an optional function that provides valid non-flag arguments for shell completion.
        // It is a dynamic version of using ValidArgs.
        // Only one of ValidArgs and ValidArgsFunction can be used for a command.
        ValidArgsFunction func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)

        // Expected arguments
        Args PositionalArgs

        // ArgAliases is List of aliases for ValidArgs.
        // These are not suggested to the user in the shell completion,
        // but accepted if entered manually.
        ArgAliases []string

        // BashCompletionFunction is custom bash functions used by the legacy bash autocompletion generator.
        // For portability with other shells, it is recommended to instead use ValidArgsFunction
        BashCompletionFunction string

        // Deprecated defines, if this command is deprecated and should print this string when used.
        Deprecated string

        // Annotations are key/value pairs that can be used by applications to identify or
        // group commands or set special options.
        Annotations map[string]string

        // Version defines the version for this command. If this value is non-empty and the command does not
        // define a "version" flag, a "version" boolean flag will be added to the command and, if specified,
        // will print content of the "Version" variable. A shorthand "v" flag will also be added if the
        // command does not define one.
        Version string

        // The *Run functions are executed in the following order:
        //   * PersistentPreRun()
        //   * PreRun()
        //   * Run()
        //   * PostRun()
        //   * PersistentPostRun()
        // All functions get the same args, the arguments after the command name.
        // The *PreRun and *PostRun functions will only be executed if the Run function of the current
        // command has been declared.
        //
        // PersistentPreRun: children of this command will inherit and execute.
        PersistentPreRun func(cmd *Command, args []string)
        // PersistentPreRunE: PersistentPreRun but returns an error.
        PersistentPreRunE func(cmd *Command, args []string) error
        // PreRun: children of this command will not inherit.
        PreRun func(cmd *Command, args []string)
        // PreRunE: PreRun but returns an error.
        PreRunE func(cmd *Command, args []string) error
        // Run: Typically the actual work function. Most commands will only implement this.
        Run func(cmd *Command, args []string)
        // RunE: Run but returns an error.
        RunE func(cmd *Command, args []string) error
        // PostRun: run after the Run command.
        PostRun func(cmd *Command, args []string)
        // PostRunE: PostRun but returns an error.
        PostRunE func(cmd *Command, args []string) error
        // PersistentPostRun: children of this command will inherit and execute after PostRun.
        PersistentPostRun func(cmd *Command, args []string)
        // PersistentPostRunE: PersistentPostRun but returns an error.
        PersistentPostRunE func(cmd *Command, args []string) error

        // groups for subcommands
        commandgroups []*Group

        // args is actual args parsed from flags.
        args []string
        // flagErrorBuf contains all error messages from pflag.
        flagErrorBuf *bytes.Buffer
        // flags is full set of flags.
        flags *flag.FlagSet
        // pflags contains persistent flags.
        pflags *flag.FlagSet
        // lflags contains local flags.
        // This field does not represent internal state, it's used as a cache to optimise LocalFlags function call
        lflags *flag.FlagSet
        // iflags contains inherited flags.
        // This field does not represent internal state, it's used as a cache to optimise InheritedFlags function call
        iflags *flag.FlagSet
        // parentsPflags is all persistent flags of cmd's parents.
        parentsPflags *flag.FlagSet
        // globNormFunc is the global normalization function
        // that we can use on every pflag set and children commands
        globNormFunc func(f *flag.FlagSet, name string) flag.NormalizedName

        // usageFunc is usage func defined by user.
        usageFunc func(*Command) error
        // usageTemplate is usage template defined by user.
        usageTemplate string
        // flagErrorFunc is func defined by user and it's called when the parsing of
        // flags returns an error.
        flagErrorFunc func(*Command, error) error
        // helpTemplate is help template defined by user.
        helpTemplate string
        // helpFunc is help func defined by user.
        helpFunc func(*Command, []string)
        // helpCommand is command with usage 'help'. If it's not defined by user,
        // cobra uses default help command.
        helpCommand *Command
        // helpCommandGroupID is the group id for the helpCommand
        helpCommandGroupID string

        // completionCommandGroupID is the group id for the completion command
        completionCommandGroupID string

        // versionTemplate is the version template defined by user.
        versionTemplate string

        // errPrefix is the error message prefix defined by user.
        errPrefix string

        // inReader is a reader defined by the user that replaces stdin
        inReader io.Reader
        // outWriter is a writer defined by the user that replaces stdout
        outWriter io.Writer
        // errWriter is a writer defined by the user that replaces stderr
        errWriter io.Writer

        // FParseErrWhitelist flag parse errors to be ignored
        FParseErrWhitelist FParseErrWhitelist

        // CompletionOptions is a set of options to control the handling of shell completion
        CompletionOptions CompletionOptions

        // commandsAreSorted defines, if command slice are sorted or not.
        commandsAreSorted bool
        // commandCalledAs is the name or alias value used to call this command.
        commandCalledAs struct {
                name   string
                called bool
        }

        ctx context.Context

        // commands is the list of commands supported by this program.
        commands []*Command
        // parent is a parent command for this command.
        parent *Command
        // Max lengths of commands' string lengths for use in padding.
        commandsMaxUseLen         int
        commandsMaxCommandPathLen int
        commandsMaxNameLen        int

        // TraverseChildren parses flags on all parents before executing child command.
        TraverseChildren bool

        // Hidden defines, if this command is hidden and should NOT show up in the list of available commands.
        Hidden bool

        // SilenceErrors is an option to quiet errors down stream.
        SilenceErrors bool

        // SilenceUsage is an option to silence usage when an error occurs.
        SilenceUsage bool

        // DisableFlagParsing disables the flag parsing.
        // If this is true all flags will be passed to the command as arguments.
        DisableFlagParsing bool

        // DisableAutoGenTag defines, if gen tag ("Auto generated by spf13/cobra...")
        // will be printed by generating docs for this command.
        DisableAutoGenTag bool

        // DisableFlagsInUseLine will disable the addition of [flags] to the usage
        // line of a command when printing help or generating docs
        DisableFlagsInUseLine bool

        // DisableSuggestions disables the suggestions based on Levenshtein distance
        // that go along with 'unknown command' messages.
        DisableSuggestions bool

        // SuggestionsMinimumDistance defines minimum levenshtein distance to display suggestions.
        // Must be &gt; 0.
        SuggestionsMinimumDistance int
}

// Context returns underlying command context. If command was executed
// with ExecuteContext or the context was set with SetContext, the
// previously set context will be returned. Otherwise, nil is returned.
//
// Notice that a call to Execute and ExecuteC will replace a nil context of
// a command with a context.Background, so a background context will be
// returned by Context after one of these functions has been called.
func (c *Command) Context() context.Context <span class="cov8" title="1">{
        return c.ctx
}</span>

// SetContext sets context for the command. This context will be overwritten by
// Command.ExecuteContext or Command.ExecuteContextC.
func (c *Command) SetContext(ctx context.Context) <span class="cov8" title="1">{
        c.ctx = ctx
}</span>

// SetArgs sets arguments for the command. It is set to os.Args[1:] by default, if desired, can be overridden
// particularly useful when testing.
func (c *Command) SetArgs(a []string) <span class="cov8" title="1">{
        c.args = a
}</span>

// SetOutput sets the destination for usage and error messages.
// If output is nil, os.Stderr is used.
// Deprecated: Use SetOut and/or SetErr instead
func (c *Command) SetOutput(output io.Writer) <span class="cov8" title="1">{
        c.outWriter = output
        c.errWriter = output
}</span>

// SetOut sets the destination for usage messages.
// If newOut is nil, os.Stdout is used.
func (c *Command) SetOut(newOut io.Writer) <span class="cov8" title="1">{
        c.outWriter = newOut
}</span>

// SetErr sets the destination for error messages.
// If newErr is nil, os.Stderr is used.
func (c *Command) SetErr(newErr io.Writer) <span class="cov8" title="1">{
        c.errWriter = newErr
}</span>

// SetIn sets the source for input data
// If newIn is nil, os.Stdin is used.
func (c *Command) SetIn(newIn io.Reader) <span class="cov8" title="1">{
        c.inReader = newIn
}</span>

// SetUsageFunc sets usage function. Usage can be defined by application.
func (c *Command) SetUsageFunc(f func(*Command) error) <span class="cov0" title="0">{
        c.usageFunc = f
}</span>

// SetUsageTemplate sets usage template. Can be defined by Application.
func (c *Command) SetUsageTemplate(s string) <span class="cov8" title="1">{
        c.usageTemplate = s
}</span>

// SetFlagErrorFunc sets a function to generate an error when flag parsing
// fails.
func (c *Command) SetFlagErrorFunc(f func(*Command, error) error) <span class="cov8" title="1">{
        c.flagErrorFunc = f
}</span>

// SetHelpFunc sets help function. Can be defined by Application.
func (c *Command) SetHelpFunc(f func(*Command, []string)) <span class="cov0" title="0">{
        c.helpFunc = f
}</span>

// SetHelpCommand sets help command.
func (c *Command) SetHelpCommand(cmd *Command) <span class="cov8" title="1">{
        c.helpCommand = cmd
}</span>

// SetHelpCommandGroupID sets the group id of the help command.
func (c *Command) SetHelpCommandGroupID(groupID string) <span class="cov8" title="1">{
        if c.helpCommand != nil </span><span class="cov0" title="0">{
                c.helpCommand.GroupID = groupID
        }</span>
        // helpCommandGroupID is used if no helpCommand is defined by the user
        <span class="cov8" title="1">c.helpCommandGroupID = groupID</span>
}

// SetCompletionCommandGroupID sets the group id of the completion command.
func (c *Command) SetCompletionCommandGroupID(groupID string) <span class="cov8" title="1">{
        // completionCommandGroupID is used if no completion command is defined by the user
        c.Root().completionCommandGroupID = groupID
}</span>

// SetHelpTemplate sets help template to be used. Application can use it to set custom template.
func (c *Command) SetHelpTemplate(s string) <span class="cov0" title="0">{
        c.helpTemplate = s
}</span>

// SetVersionTemplate sets version template to be used. Application can use it to set custom template.
func (c *Command) SetVersionTemplate(s string) <span class="cov8" title="1">{
        c.versionTemplate = s
}</span>

// SetErrPrefix sets error message prefix to be used. Application can use it to set custom prefix.
func (c *Command) SetErrPrefix(s string) <span class="cov8" title="1">{
        c.errPrefix = s
}</span>

// SetGlobalNormalizationFunc sets a normalization function to all flag sets and also to child commands.
// The user should not have a cyclic dependency on commands.
func (c *Command) SetGlobalNormalizationFunc(n func(f *flag.FlagSet, name string) flag.NormalizedName) <span class="cov8" title="1">{
        c.Flags().SetNormalizeFunc(n)
        c.PersistentFlags().SetNormalizeFunc(n)
        c.globNormFunc = n

        for _, command := range c.commands </span><span class="cov8" title="1">{
                command.SetGlobalNormalizationFunc(n)
        }</span>
}

// OutOrStdout returns output to stdout.
func (c *Command) OutOrStdout() io.Writer <span class="cov8" title="1">{
        return c.getOut(os.Stdout)
}</span>

// OutOrStderr returns output to stderr
func (c *Command) OutOrStderr() io.Writer <span class="cov8" title="1">{
        return c.getOut(os.Stderr)
}</span>

// ErrOrStderr returns output to stderr
func (c *Command) ErrOrStderr() io.Writer <span class="cov8" title="1">{
        return c.getErr(os.Stderr)
}</span>

// InOrStdin returns input to stdin
func (c *Command) InOrStdin() io.Reader <span class="cov8" title="1">{
        return c.getIn(os.Stdin)
}</span>

func (c *Command) getOut(def io.Writer) io.Writer <span class="cov8" title="1">{
        if c.outWriter != nil </span><span class="cov8" title="1">{
                return c.outWriter
        }</span>
        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.parent.getOut(def)
        }</span>
        <span class="cov8" title="1">return def</span>
}

func (c *Command) getErr(def io.Writer) io.Writer <span class="cov8" title="1">{
        if c.errWriter != nil </span><span class="cov8" title="1">{
                return c.errWriter
        }</span>
        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.parent.getErr(def)
        }</span>
        <span class="cov8" title="1">return def</span>
}

func (c *Command) getIn(def io.Reader) io.Reader <span class="cov8" title="1">{
        if c.inReader != nil </span><span class="cov0" title="0">{
                return c.inReader
        }</span>
        <span class="cov8" title="1">if c.HasParent() </span><span class="cov0" title="0">{
                return c.parent.getIn(def)
        }</span>
        <span class="cov8" title="1">return def</span>
}

// UsageFunc returns either the function set by SetUsageFunc for this command
// or a parent, or it returns a default usage function.
func (c *Command) UsageFunc() (f func(*Command) error) <span class="cov8" title="1">{
        if c.usageFunc != nil </span><span class="cov8" title="1">{
                return c.usageFunc
        }</span>
        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.Parent().UsageFunc()
        }</span>
        <span class="cov8" title="1">return func(c *Command) error </span><span class="cov8" title="1">{
                c.mergePersistentFlags()
                err := tmpl(c.OutOrStderr(), c.UsageTemplate(), c)
                if err != nil </span><span class="cov0" title="0">{
                        c.PrintErrln(err)
                }</span>
                <span class="cov8" title="1">return err</span>
        }
}

// Usage puts out the usage for the command.
// Used when a user provides invalid input.
// Can be defined by user by overriding UsageFunc.
func (c *Command) Usage() error <span class="cov8" title="1">{
        return c.UsageFunc()(c)
}</span>

// HelpFunc returns either the function set by SetHelpFunc for this command
// or a parent, or it returns a function with default help behavior.
func (c *Command) HelpFunc() func(*Command, []string) <span class="cov8" title="1">{
        if c.helpFunc != nil </span><span class="cov0" title="0">{
                return c.helpFunc
        }</span>
        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.Parent().HelpFunc()
        }</span>
        <span class="cov8" title="1">return func(c *Command, a []string) </span><span class="cov8" title="1">{
                c.mergePersistentFlags()
                // The help should be sent to stdout
                // See https://github.com/spf13/cobra/issues/1002
                err := tmpl(c.OutOrStdout(), c.HelpTemplate(), c)
                if err != nil </span><span class="cov0" title="0">{
                        c.PrintErrln(err)
                }</span>
        }
}

// Help puts out the help for the command.
// Used when a user calls help [command].
// Can be defined by user by overriding HelpFunc.
func (c *Command) Help() error <span class="cov8" title="1">{
        c.HelpFunc()(c, []string{})
        return nil
}</span>

// UsageString returns usage string.
func (c *Command) UsageString() string <span class="cov8" title="1">{
        // Storing normal writers
        tmpOutput := c.outWriter
        tmpErr := c.errWriter

        bb := new(bytes.Buffer)
        c.outWriter = bb
        c.errWriter = bb

        CheckErr(c.Usage())

        // Setting things back to normal
        c.outWriter = tmpOutput
        c.errWriter = tmpErr

        return bb.String()
}</span>

// FlagErrorFunc returns either the function set by SetFlagErrorFunc for this
// command or a parent, or it returns a function which returns the original
// error.
func (c *Command) FlagErrorFunc() (f func(*Command, error) error) <span class="cov8" title="1">{
        if c.flagErrorFunc != nil </span><span class="cov8" title="1">{
                return c.flagErrorFunc
        }</span>

        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.parent.FlagErrorFunc()
        }</span>
        <span class="cov8" title="1">return func(c *Command, err error) error </span><span class="cov8" title="1">{
                return err
        }</span>
}

var minUsagePadding = 25

// UsagePadding return padding for the usage.
func (c *Command) UsagePadding() int <span class="cov0" title="0">{
        if c.parent == nil || minUsagePadding &gt; c.parent.commandsMaxUseLen </span><span class="cov0" title="0">{
                return minUsagePadding
        }</span>
        <span class="cov0" title="0">return c.parent.commandsMaxUseLen</span>
}

var minCommandPathPadding = 11

// CommandPathPadding return padding for the command path.
func (c *Command) CommandPathPadding() int <span class="cov8" title="1">{
        if c.parent == nil || minCommandPathPadding &gt; c.parent.commandsMaxCommandPathLen </span><span class="cov0" title="0">{
                return minCommandPathPadding
        }</span>
        <span class="cov8" title="1">return c.parent.commandsMaxCommandPathLen</span>
}

var minNamePadding = 11

// NamePadding returns padding for the name.
func (c *Command) NamePadding() int <span class="cov8" title="1">{
        if c.parent == nil || minNamePadding &gt; c.parent.commandsMaxNameLen </span><span class="cov8" title="1">{
                return minNamePadding
        }</span>
        <span class="cov0" title="0">return c.parent.commandsMaxNameLen</span>
}

// UsageTemplate returns usage template for the command.
func (c *Command) UsageTemplate() string <span class="cov8" title="1">{
        if c.usageTemplate != "" </span><span class="cov8" title="1">{
                return c.usageTemplate
        }</span>

        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.parent.UsageTemplate()
        }</span>
        <span class="cov8" title="1">return `Usage:{{if .Runnable}}
  {{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
  {{.CommandPath}} [command]{{end}}{{if gt (len .Aliases) 0}}

Aliases:
  {{.NameAndAliases}}{{end}}{{if .HasExample}}

Examples:
{{.Example}}{{end}}{{if .HasAvailableSubCommands}}{{$cmds := .Commands}}{{if eq (len .Groups) 0}}

Available Commands:{{range $cmds}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{else}}{{range $group := .Groups}}

{{.Title}}{{range $cmds}}{{if (and (eq .GroupID $group.ID) (or .IsAvailableCommand (eq .Name "help")))}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{if not .AllChildCommandsHaveGroup}}

Additional Commands:{{range $cmds}}{{if (and (eq .GroupID "") (or .IsAvailableCommand (eq .Name "help")))}}
  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}

Flags:
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasAvailableInheritedFlags}}

Global Flags:
{{.InheritedFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasHelpSubCommands}}

Additional help topics:{{range .Commands}}{{if .IsAdditionalHelpTopicCommand}}
  {{rpad .CommandPath .CommandPathPadding}} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableSubCommands}}

Use "{{.CommandPath}} [command] --help" for more information about a command.{{end}}
`</span>
}

// HelpTemplate return help template for the command.
func (c *Command) HelpTemplate() string <span class="cov8" title="1">{
        if c.helpTemplate != "" </span><span class="cov0" title="0">{
                return c.helpTemplate
        }</span>

        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.parent.HelpTemplate()
        }</span>
        <span class="cov8" title="1">return `{{with (or .Long .Short)}}{{. | trimTrailingWhitespaces}}

{{end}}{{if or .Runnable .HasSubCommands}}{{.UsageString}}{{end}}`</span>
}

// VersionTemplate return version template for the command.
func (c *Command) VersionTemplate() string <span class="cov8" title="1">{
        if c.versionTemplate != "" </span><span class="cov8" title="1">{
                return c.versionTemplate
        }</span>

        <span class="cov8" title="1">if c.HasParent() </span><span class="cov0" title="0">{
                return c.parent.VersionTemplate()
        }</span>
        <span class="cov8" title="1">return `{{with .Name}}{{printf "%s " .}}{{end}}{{printf "version %s" .Version}}
`</span>
}

// ErrPrefix return error message prefix for the command
func (c *Command) ErrPrefix() string <span class="cov8" title="1">{
        if c.errPrefix != "" </span><span class="cov8" title="1">{
                return c.errPrefix
        }</span>

        <span class="cov8" title="1">if c.HasParent() </span><span class="cov8" title="1">{
                return c.parent.ErrPrefix()
        }</span>
        <span class="cov8" title="1">return "Error:"</span>
}

func hasNoOptDefVal(name string, fs *flag.FlagSet) bool <span class="cov8" title="1">{
        flag := fs.Lookup(name)
        if flag == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return flag.NoOptDefVal != ""</span>
}

func shortHasNoOptDefVal(name string, fs *flag.FlagSet) bool <span class="cov8" title="1">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">flag := fs.ShorthandLookup(name[:1])
        if flag == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return flag.NoOptDefVal != ""</span>
}

func stripFlags(args []string, c *Command) []string <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return args
        }</span>
        <span class="cov8" title="1">c.mergePersistentFlags()

        commands := []string{}
        flags := c.Flags()

Loop:
        for len(args) &gt; 0 </span><span class="cov8" title="1">{
                s := args[0]
                args = args[1:]
                switch </span>{
                case s == "--":<span class="cov8" title="1">
                        // "--" terminates the flags
                        break Loop</span>
                case strings.HasPrefix(s, "--") &amp;&amp; !strings.Contains(s, "=") &amp;&amp; !hasNoOptDefVal(s[2:], flags):<span class="cov8" title="1">
                        // If '--flag arg' then
                        // delete arg from args.
                        fallthrough</span> // (do the same as below)
                case strings.HasPrefix(s, "-") &amp;&amp; !strings.Contains(s, "=") &amp;&amp; len(s) == 2 &amp;&amp; !shortHasNoOptDefVal(s[1:], flags):<span class="cov8" title="1">
                        // If '-f arg' then
                        // delete 'arg' from args or break the loop if len(args) &lt;= 1.
                        if len(args) &lt;= 1 </span><span class="cov8" title="1">{
                                break Loop</span>
                        } else<span class="cov8" title="1"> {
                                args = args[1:]
                                continue</span>
                        }
                case s != "" &amp;&amp; !strings.HasPrefix(s, "-"):<span class="cov8" title="1">
                        commands = append(commands, s)</span>
                }
        }

        <span class="cov8" title="1">return commands</span>
}

// argsMinusFirstX removes only the first x from args.  Otherwise, commands that look like
// openshift admin policy add-role-to-user admin my-user, lose the admin argument (arg[4]).
// Special care needs to be taken not to remove a flag value.
func (c *Command) argsMinusFirstX(args []string, x string) []string <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return args
        }</span>
        <span class="cov8" title="1">c.mergePersistentFlags()
        flags := c.Flags()

Loop:
        for pos := 0; pos &lt; len(args); pos++ </span><span class="cov8" title="1">{
                s := args[pos]
                switch </span>{
                case s == "--":<span class="cov0" title="0">
                        // -- means we have reached the end of the parseable args. Break out of the loop now.
                        break Loop</span>
                case strings.HasPrefix(s, "--") &amp;&amp; !strings.Contains(s, "=") &amp;&amp; !hasNoOptDefVal(s[2:], flags):<span class="cov8" title="1">
                        fallthrough</span>
                case strings.HasPrefix(s, "-") &amp;&amp; !strings.Contains(s, "=") &amp;&amp; len(s) == 2 &amp;&amp; !shortHasNoOptDefVal(s[1:], flags):<span class="cov8" title="1">
                        // This is a flag without a default value, and an equal sign is not used. Increment pos in order to skip
                        // over the next arg, because that is the value of this flag.
                        pos++
                        continue</span>
                case !strings.HasPrefix(s, "-"):<span class="cov8" title="1">
                        // This is not a flag or a flag value. Check to see if it matches what we're looking for, and if so,
                        // return the args, excluding the one at this position.
                        if s == x </span><span class="cov8" title="1">{
                                ret := make([]string, 0, len(args)-1)
                                ret = append(ret, args[:pos]...)
                                ret = append(ret, args[pos+1:]...)
                                return ret
                        }</span>
                }
        }
        <span class="cov0" title="0">return args</span>
}

func isFlagArg(arg string) bool <span class="cov8" title="1">{
        return ((len(arg) &gt;= 3 &amp;&amp; arg[0:2] == "--") ||
                (len(arg) &gt;= 2 &amp;&amp; arg[0] == '-' &amp;&amp; arg[1] != '-'))
}</span>

// Find the target command given the args and command tree
// Meant to be run on the highest node. Only searches down.
func (c *Command) Find(args []string) (*Command, []string, error) <span class="cov8" title="1">{
        var innerfind func(*Command, []string) (*Command, []string)

        innerfind = func(c *Command, innerArgs []string) (*Command, []string) </span><span class="cov8" title="1">{
                argsWOflags := stripFlags(innerArgs, c)
                if len(argsWOflags) == 0 </span><span class="cov8" title="1">{
                        return c, innerArgs
                }</span>
                <span class="cov8" title="1">nextSubCmd := argsWOflags[0]

                cmd := c.findNext(nextSubCmd)
                if cmd != nil </span><span class="cov8" title="1">{
                        return innerfind(cmd, c.argsMinusFirstX(innerArgs, nextSubCmd))
                }</span>
                <span class="cov8" title="1">return c, innerArgs</span>
        }

        <span class="cov8" title="1">commandFound, a := innerfind(c, args)
        if commandFound.Args == nil </span><span class="cov8" title="1">{
                return commandFound, a, legacyArgs(commandFound, stripFlags(a, commandFound))
        }</span>
        <span class="cov8" title="1">return commandFound, a, nil</span>
}

func (c *Command) findSuggestions(arg string) string <span class="cov8" title="1">{
        if c.DisableSuggestions </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if c.SuggestionsMinimumDistance &lt;= 0 </span><span class="cov8" title="1">{
                c.SuggestionsMinimumDistance = 2
        }</span>
        <span class="cov8" title="1">var sb strings.Builder
        if suggestions := c.SuggestionsFor(arg); len(suggestions) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("\n\nDid you mean this?\n")
                for _, s := range suggestions </span><span class="cov8" title="1">{
                        _, _ = fmt.Fprintf(&amp;sb, "\t%v\n", s)
                }</span>
        }
        <span class="cov8" title="1">return sb.String()</span>
}

func (c *Command) findNext(next string) *Command <span class="cov8" title="1">{
        matches := make([]*Command, 0)
        for _, cmd := range c.commands </span><span class="cov8" title="1">{
                if commandNameMatches(cmd.Name(), next) || cmd.HasAlias(next) </span><span class="cov8" title="1">{
                        cmd.commandCalledAs.name = next
                        return cmd
                }</span>
                <span class="cov8" title="1">if EnablePrefixMatching &amp;&amp; cmd.hasNameOrAliasPrefix(next) </span><span class="cov8" title="1">{
                        matches = append(matches, cmd)
                }</span>
        }

        <span class="cov8" title="1">if len(matches) == 1 </span><span class="cov8" title="1">{
                // Temporarily disable gosec G602, which produces a false positive.
                // See https://github.com/securego/gosec/issues/1005.
                return matches[0] // #nosec G602
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Traverse the command tree to find the command, and parse args for
// each parent.
func (c *Command) Traverse(args []string) (*Command, []string, error) <span class="cov8" title="1">{
        flags := []string{}
        inFlag := false

        for i, arg := range args </span><span class="cov8" title="1">{
                switch </span>{
                // A long flag with a space separated value
                case strings.HasPrefix(arg, "--") &amp;&amp; !strings.Contains(arg, "="):<span class="cov8" title="1">
                        // TODO: this isn't quite right, we should really check ahead for 'true' or 'false'
                        inFlag = !hasNoOptDefVal(arg[2:], c.Flags())
                        flags = append(flags, arg)
                        continue</span>
                // A short flag with a space separated value
                case strings.HasPrefix(arg, "-") &amp;&amp; !strings.Contains(arg, "=") &amp;&amp; len(arg) == 2 &amp;&amp; !shortHasNoOptDefVal(arg[1:], c.Flags()):<span class="cov0" title="0">
                        inFlag = true
                        flags = append(flags, arg)
                        continue</span>
                // The value for a flag
                case inFlag:<span class="cov8" title="1">
                        inFlag = false
                        flags = append(flags, arg)
                        continue</span>
                // A flag without a value, or with an `=` separated value
                case isFlagArg(arg):<span class="cov8" title="1">
                        flags = append(flags, arg)
                        continue</span>
                }

                <span class="cov8" title="1">cmd := c.findNext(arg)
                if cmd == nil </span><span class="cov8" title="1">{
                        return c, args, nil
                }</span>

                <span class="cov8" title="1">if err := c.ParseFlags(flags); err != nil </span><span class="cov8" title="1">{
                        return nil, args, err
                }</span>
                <span class="cov8" title="1">return cmd.Traverse(args[i+1:])</span>
        }
        <span class="cov8" title="1">return c, args, nil</span>
}

// SuggestionsFor provides suggestions for the typedName.
func (c *Command) SuggestionsFor(typedName string) []string <span class="cov8" title="1">{
        suggestions := []string{}
        for _, cmd := range c.commands </span><span class="cov8" title="1">{
                if cmd.IsAvailableCommand() </span><span class="cov8" title="1">{
                        levenshteinDistance := ld(typedName, cmd.Name(), true)
                        suggestByLevenshtein := levenshteinDistance &lt;= c.SuggestionsMinimumDistance
                        suggestByPrefix := strings.HasPrefix(strings.ToLower(cmd.Name()), strings.ToLower(typedName))
                        if suggestByLevenshtein || suggestByPrefix </span><span class="cov8" title="1">{
                                suggestions = append(suggestions, cmd.Name())
                        }</span>
                        <span class="cov8" title="1">for _, explicitSuggestion := range cmd.SuggestFor </span><span class="cov8" title="1">{
                                if strings.EqualFold(typedName, explicitSuggestion) </span><span class="cov8" title="1">{
                                        suggestions = append(suggestions, cmd.Name())
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return suggestions</span>
}

// VisitParents visits all parents of the command and invokes fn on each parent.
func (c *Command) VisitParents(fn func(*Command)) <span class="cov8" title="1">{
        if c.HasParent() </span><span class="cov8" title="1">{
                fn(c.Parent())
                c.Parent().VisitParents(fn)
        }</span>
}

// Root finds root command.
func (c *Command) Root() *Command <span class="cov8" title="1">{
        if c.HasParent() </span><span class="cov8" title="1">{
                return c.Parent().Root()
        }</span>
        <span class="cov8" title="1">return c</span>
}

// ArgsLenAtDash will return the length of c.Flags().Args at the moment
// when a -- was found during args parsing.
func (c *Command) ArgsLenAtDash() int <span class="cov8" title="1">{
        return c.Flags().ArgsLenAtDash()
}</span>

func (c *Command) execute(a []string) (err error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("called Execute() on a nil Command")
        }</span>

        <span class="cov8" title="1">if len(c.Deprecated) &gt; 0 </span><span class="cov8" title="1">{
                c.Printf("Command %q is deprecated, %s\n", c.Name(), c.Deprecated)
        }</span>

        // initialize help and version flag at the last point possible to allow for user
        // overriding
        <span class="cov8" title="1">c.InitDefaultHelpFlag()
        c.InitDefaultVersionFlag()

        err = c.ParseFlags(a)
        if err != nil </span><span class="cov8" title="1">{
                return c.FlagErrorFunc()(c, err)
        }</span>

        // If help is called, regardless of other flags, return we want help.
        // Also say we need help if the command isn't runnable.
        <span class="cov8" title="1">helpVal, err := c.Flags().GetBool("help")
        if err != nil </span><span class="cov0" title="0">{
                // should be impossible to get here as we always declare a help
                // flag in InitDefaultHelpFlag()
                c.Println("\"help\" flag declared as non-bool. Please correct your code")
                return err
        }</span>

        <span class="cov8" title="1">if helpVal </span><span class="cov8" title="1">{
                return flag.ErrHelp
        }</span>

        // for back-compat, only add version flag behavior if version is defined
        <span class="cov8" title="1">if c.Version != "" </span><span class="cov8" title="1">{
                versionVal, err := c.Flags().GetBool("version")
                if err != nil </span><span class="cov0" title="0">{
                        c.Println("\"version\" flag declared as non-bool. Please correct your code")
                        return err
                }</span>
                <span class="cov8" title="1">if versionVal </span><span class="cov8" title="1">{
                        err := tmpl(c.OutOrStdout(), c.VersionTemplate(), c)
                        if err != nil </span><span class="cov0" title="0">{
                                c.Println(err)
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }

        <span class="cov8" title="1">if !c.Runnable() </span><span class="cov8" title="1">{
                return flag.ErrHelp
        }</span>

        <span class="cov8" title="1">c.preRun()

        defer c.postRun()

        argWoFlags := c.Flags().Args()
        if c.DisableFlagParsing </span><span class="cov8" title="1">{
                argWoFlags = a
        }</span>

        <span class="cov8" title="1">if err := c.ValidateArgs(argWoFlags); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">parents := make([]*Command, 0, 5)
        for p := c; p != nil; p = p.Parent() </span><span class="cov8" title="1">{
                if EnableTraverseRunHooks </span><span class="cov8" title="1">{
                        // When EnableTraverseRunHooks is set:
                        // - Execute all persistent pre-runs from the root parent till this command.
                        // - Execute all persistent post-runs from this command till the root parent.
                        parents = append([]*Command{p}, parents...)
                }</span> else<span class="cov8" title="1"> {
                        // Otherwise, execute only the first found persistent hook.
                        parents = append(parents, p)
                }</span>
        }
        <span class="cov8" title="1">for _, p := range parents </span><span class="cov8" title="1">{
                if p.PersistentPreRunE != nil </span><span class="cov0" title="0">{
                        if err := p.PersistentPreRunE(c, argWoFlags); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if !EnableTraverseRunHooks </span><span class="cov0" title="0">{
                                break</span>
                        }
                } else<span class="cov8" title="1"> if p.PersistentPreRun != nil </span><span class="cov8" title="1">{
                        p.PersistentPreRun(c, argWoFlags)
                        if !EnableTraverseRunHooks </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if c.PreRunE != nil </span><span class="cov0" title="0">{
                if err := c.PreRunE(c, argWoFlags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if c.PreRun != nil </span><span class="cov8" title="1">{
                c.PreRun(c, argWoFlags)
        }</span>

        <span class="cov8" title="1">if err := c.ValidateRequiredFlags(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.ValidateFlagGroups(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if c.RunE != nil </span><span class="cov8" title="1">{
                if err := c.RunE(c, argWoFlags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                c.Run(c, argWoFlags)
        }</span>
        <span class="cov8" title="1">if c.PostRunE != nil </span><span class="cov0" title="0">{
                if err := c.PostRunE(c, argWoFlags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if c.PostRun != nil </span><span class="cov8" title="1">{
                c.PostRun(c, argWoFlags)
        }</span>
        <span class="cov8" title="1">for p := c; p != nil; p = p.Parent() </span><span class="cov8" title="1">{
                if p.PersistentPostRunE != nil </span><span class="cov0" title="0">{
                        if err := p.PersistentPostRunE(c, argWoFlags); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if !EnableTraverseRunHooks </span><span class="cov0" title="0">{
                                break</span>
                        }
                } else<span class="cov8" title="1"> if p.PersistentPostRun != nil </span><span class="cov8" title="1">{
                        p.PersistentPostRun(c, argWoFlags)
                        if !EnableTraverseRunHooks </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *Command) preRun() <span class="cov8" title="1">{
        for _, x := range initializers </span><span class="cov8" title="1">{
                x()
        }</span>
}

func (c *Command) postRun() <span class="cov8" title="1">{
        for _, x := range finalizers </span><span class="cov8" title="1">{
                x()
        }</span>
}

// ExecuteContext is the same as Execute(), but sets the ctx on the command.
// Retrieve ctx by calling cmd.Context() inside your *Run lifecycle or ValidArgs
// functions.
func (c *Command) ExecuteContext(ctx context.Context) error <span class="cov8" title="1">{
        c.ctx = ctx
        return c.Execute()
}</span>

// Execute uses the args (os.Args[1:] by default)
// and run through the command tree finding appropriate matches
// for commands and then corresponding flags.
func (c *Command) Execute() error <span class="cov8" title="1">{
        _, err := c.ExecuteC()
        return err
}</span>

// ExecuteContextC is the same as ExecuteC(), but sets the ctx on the command.
// Retrieve ctx by calling cmd.Context() inside your *Run lifecycle or ValidArgs
// functions.
func (c *Command) ExecuteContextC(ctx context.Context) (*Command, error) <span class="cov8" title="1">{
        c.ctx = ctx
        return c.ExecuteC()
}</span>

// ExecuteC executes the command.
func (c *Command) ExecuteC() (cmd *Command, err error) <span class="cov8" title="1">{
        if c.ctx == nil </span><span class="cov8" title="1">{
                c.ctx = context.Background()
        }</span>

        // Regardless of what command execute is called on, run on Root only
        <span class="cov8" title="1">if c.HasParent() </span><span class="cov0" title="0">{
                return c.Root().ExecuteC()
        }</span>

        // windows hook
        <span class="cov8" title="1">if preExecHookFn != nil </span><span class="cov0" title="0">{
                preExecHookFn(c)
        }</span>

        // initialize help at the last point to allow for user overriding
        <span class="cov8" title="1">c.InitDefaultHelpCmd()
        // initialize completion at the last point to allow for user overriding
        c.InitDefaultCompletionCmd()

        // Now that all commands have been created, let's make sure all groups
        // are properly created also
        c.checkCommandGroups()

        args := c.args

        // Workaround FAIL with "go test -v" or "cobra.test -test.v", see #155
        if c.args == nil &amp;&amp; filepath.Base(os.Args[0]) != "cobra.test" </span><span class="cov0" title="0">{
                args = os.Args[1:]
        }</span>

        // initialize the hidden command to be used for shell completion
        <span class="cov8" title="1">c.initCompleteCmd(args)

        var flags []string
        if c.TraverseChildren </span><span class="cov8" title="1">{
                cmd, flags, err = c.Traverse(args)
        }</span> else<span class="cov8" title="1"> {
                cmd, flags, err = c.Find(args)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // If found parse to a subcommand and then failed, talk about the subcommand
                if cmd != nil </span><span class="cov8" title="1">{
                        c = cmd
                }</span>
                <span class="cov8" title="1">if !c.SilenceErrors </span><span class="cov8" title="1">{
                        c.PrintErrln(c.ErrPrefix(), err.Error())
                        c.PrintErrf("Run '%v --help' for usage.\n", c.CommandPath())
                }</span>
                <span class="cov8" title="1">return c, err</span>
        }

        <span class="cov8" title="1">cmd.commandCalledAs.called = true
        if cmd.commandCalledAs.name == "" </span><span class="cov8" title="1">{
                cmd.commandCalledAs.name = cmd.Name()
        }</span>

        // We have to pass global context to children command
        // if context is present on the parent command.
        <span class="cov8" title="1">if cmd.ctx == nil </span><span class="cov8" title="1">{
                cmd.ctx = c.ctx
        }</span>

        <span class="cov8" title="1">err = cmd.execute(flags)
        if err != nil </span><span class="cov8" title="1">{
                // Always show help if requested, even if SilenceErrors is in
                // effect
                if errors.Is(err, flag.ErrHelp) </span><span class="cov8" title="1">{
                        cmd.HelpFunc()(cmd, args)
                        return cmd, nil
                }</span>

                // If root command has SilenceErrors flagged,
                // all subcommands should respect it
                <span class="cov8" title="1">if !cmd.SilenceErrors &amp;&amp; !c.SilenceErrors </span><span class="cov8" title="1">{
                        c.PrintErrln(cmd.ErrPrefix(), err.Error())
                }</span>

                // If root command has SilenceUsage flagged,
                // all subcommands should respect it
                <span class="cov8" title="1">if !cmd.SilenceUsage &amp;&amp; !c.SilenceUsage </span><span class="cov8" title="1">{
                        c.Println(cmd.UsageString())
                }</span>
        }
        <span class="cov8" title="1">return cmd, err</span>
}

func (c *Command) ValidateArgs(args []string) error <span class="cov8" title="1">{
        if c.Args == nil </span><span class="cov8" title="1">{
                return ArbitraryArgs(c, args)
        }</span>
        <span class="cov8" title="1">return c.Args(c, args)</span>
}

// ValidateRequiredFlags validates all required flags are present and returns an error otherwise
func (c *Command) ValidateRequiredFlags() error <span class="cov8" title="1">{
        if c.DisableFlagParsing </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">flags := c.Flags()
        missingFlagNames := []string{}
        flags.VisitAll(func(pflag *flag.Flag) </span><span class="cov8" title="1">{
                requiredAnnotation, found := pflag.Annotations[BashCompOneRequiredFlag]
                if !found </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if (requiredAnnotation[0] == "true") &amp;&amp; !pflag.Changed </span><span class="cov8" title="1">{
                        missingFlagNames = append(missingFlagNames, pflag.Name)
                }</span>
        })

        <span class="cov8" title="1">if len(missingFlagNames) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf(`required flag(s) "%s" not set`, strings.Join(missingFlagNames, `", "`))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// checkCommandGroups checks if a command has been added to a group that does not exists.
// If so, we panic because it indicates a coding error that should be corrected.
func (c *Command) checkCommandGroups() <span class="cov8" title="1">{
        for _, sub := range c.commands </span><span class="cov8" title="1">{
                // if Group is not defined let the developer know right away
                if sub.GroupID != "" &amp;&amp; !c.ContainsGroup(sub.GroupID) </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("group id '%s' is not defined for subcommand '%s'", sub.GroupID, sub.CommandPath()))</span>
                }

                <span class="cov8" title="1">sub.checkCommandGroups()</span>
        }
}

// InitDefaultHelpFlag adds default help flag to c.
// It is called automatically by executing the c or by calling help and usage.
// If c already has help flag, it will do nothing.
func (c *Command) InitDefaultHelpFlag() <span class="cov8" title="1">{
        c.mergePersistentFlags()
        if c.Flags().Lookup("help") == nil </span><span class="cov8" title="1">{
                usage := "help for "
                name := c.displayName()
                if name == "" </span><span class="cov8" title="1">{
                        usage += "this command"
                }</span> else<span class="cov8" title="1"> {
                        usage += name
                }</span>
                <span class="cov8" title="1">c.Flags().BoolP("help", "h", false, usage)
                _ = c.Flags().SetAnnotation("help", FlagSetByCobraAnnotation, []string{"true"})</span>
        }
}

// InitDefaultVersionFlag adds default version flag to c.
// It is called automatically by executing the c.
// If c already has a version flag, it will do nothing.
// If c.Version is empty, it will do nothing.
func (c *Command) InitDefaultVersionFlag() <span class="cov8" title="1">{
        if c.Version == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c.mergePersistentFlags()
        if c.Flags().Lookup("version") == nil </span><span class="cov8" title="1">{
                usage := "version for "
                if c.Name() == "" </span><span class="cov8" title="1">{
                        usage += "this command"
                }</span> else<span class="cov8" title="1"> {
                        usage += c.Name()
                }</span>
                <span class="cov8" title="1">if c.Flags().ShorthandLookup("v") == nil </span><span class="cov8" title="1">{
                        c.Flags().BoolP("version", "v", false, usage)
                }</span> else<span class="cov8" title="1"> {
                        c.Flags().Bool("version", false, usage)
                }</span>
                <span class="cov8" title="1">_ = c.Flags().SetAnnotation("version", FlagSetByCobraAnnotation, []string{"true"})</span>
        }
}

// InitDefaultHelpCmd adds default help command to c.
// It is called automatically by executing the c or by calling help and usage.
// If c already has help command or c has no subcommands, it will do nothing.
func (c *Command) InitDefaultHelpCmd() <span class="cov8" title="1">{
        if !c.HasSubCommands() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if c.helpCommand == nil </span><span class="cov8" title="1">{
                c.helpCommand = &amp;Command{
                        Use:   "help [command]",
                        Short: "Help about any command",
                        Long: `Help provides help for any command in the application.
Simply type ` + c.displayName() + ` help [path to command] for full details.`,
                        ValidArgsFunction: func(c *Command, args []string, toComplete string) ([]string, ShellCompDirective) </span><span class="cov8" title="1">{
                                var completions []string
                                cmd, _, e := c.Root().Find(args)
                                if e != nil </span><span class="cov0" title="0">{
                                        return nil, ShellCompDirectiveNoFileComp
                                }</span>
                                <span class="cov8" title="1">if cmd == nil </span><span class="cov0" title="0">{
                                        // Root help command.
                                        cmd = c.Root()
                                }</span>
                                <span class="cov8" title="1">for _, subCmd := range cmd.Commands() </span><span class="cov8" title="1">{
                                        if subCmd.IsAvailableCommand() || subCmd == cmd.helpCommand </span><span class="cov8" title="1">{
                                                if strings.HasPrefix(subCmd.Name(), toComplete) </span><span class="cov8" title="1">{
                                                        completions = append(completions, fmt.Sprintf("%s\t%s", subCmd.Name(), subCmd.Short))
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">return completions, ShellCompDirectiveNoFileComp</span>
                        },
                        Run: func(c *Command, args []string) <span class="cov8" title="1">{
                                cmd, _, e := c.Root().Find(args)
                                if cmd == nil || e != nil </span><span class="cov0" title="0">{
                                        c.Printf("Unknown help topic %#q\n", args)
                                        CheckErr(c.Root().Usage())
                                }</span> else<span class="cov8" title="1"> {
                                        cmd.InitDefaultHelpFlag()    // make possible 'help' flag to be shown
                                        cmd.InitDefaultVersionFlag() // make possible 'version' flag to be shown
                                        CheckErr(cmd.Help())
                                }</span>
                        },
                        GroupID: c.helpCommandGroupID,
                }
        }
        <span class="cov8" title="1">c.RemoveCommand(c.helpCommand)
        c.AddCommand(c.helpCommand)</span>
}

// ResetCommands delete parent, subcommand and help command from c.
func (c *Command) ResetCommands() <span class="cov0" title="0">{
        c.parent = nil
        c.commands = nil
        c.helpCommand = nil
        c.parentsPflags = nil
}</span>

// Sorts commands by their names.
type commandSorterByName []*Command

func (c commandSorterByName) Len() int           <span class="cov8" title="1">{ return len(c) }</span>
func (c commandSorterByName) Swap(i, j int)      <span class="cov8" title="1">{ c[i], c[j] = c[j], c[i] }</span>
func (c commandSorterByName) Less(i, j int) bool <span class="cov8" title="1">{ return c[i].Name() &lt; c[j].Name() }</span>

// Commands returns a sorted slice of child commands.
func (c *Command) Commands() []*Command <span class="cov8" title="1">{
        // do not sort commands if it already sorted or sorting was disabled
        if EnableCommandSorting &amp;&amp; !c.commandsAreSorted </span><span class="cov8" title="1">{
                sort.Sort(commandSorterByName(c.commands))
                c.commandsAreSorted = true
        }</span>
        <span class="cov8" title="1">return c.commands</span>
}

// AddCommand adds one or more commands to this parent command.
func (c *Command) AddCommand(cmds ...*Command) <span class="cov8" title="1">{
        for i, x := range cmds </span><span class="cov8" title="1">{
                if cmds[i] == c </span><span class="cov0" title="0">{
                        panic("Command can't be a child of itself")</span>
                }
                <span class="cov8" title="1">cmds[i].parent = c
                // update max lengths
                usageLen := len(x.Use)
                if usageLen &gt; c.commandsMaxUseLen </span><span class="cov8" title="1">{
                        c.commandsMaxUseLen = usageLen
                }</span>
                <span class="cov8" title="1">commandPathLen := len(x.CommandPath())
                if commandPathLen &gt; c.commandsMaxCommandPathLen </span><span class="cov8" title="1">{
                        c.commandsMaxCommandPathLen = commandPathLen
                }</span>
                <span class="cov8" title="1">nameLen := len(x.Name())
                if nameLen &gt; c.commandsMaxNameLen </span><span class="cov8" title="1">{
                        c.commandsMaxNameLen = nameLen
                }</span>
                // If global normalization function exists, update all children
                <span class="cov8" title="1">if c.globNormFunc != nil </span><span class="cov8" title="1">{
                        x.SetGlobalNormalizationFunc(c.globNormFunc)
                }</span>
                <span class="cov8" title="1">c.commands = append(c.commands, x)
                c.commandsAreSorted = false</span>
        }
}

// Groups returns a slice of child command groups.
func (c *Command) Groups() []*Group <span class="cov8" title="1">{
        return c.commandgroups
}</span>

// AllChildCommandsHaveGroup returns if all subcommands are assigned to a group
func (c *Command) AllChildCommandsHaveGroup() bool <span class="cov8" title="1">{
        for _, sub := range c.commands </span><span class="cov8" title="1">{
                if (sub.IsAvailableCommand() || sub == c.helpCommand) &amp;&amp; sub.GroupID == "" </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ContainsGroup return if groupID exists in the list of command groups.
func (c *Command) ContainsGroup(groupID string) bool <span class="cov8" title="1">{
        for _, x := range c.commandgroups </span><span class="cov8" title="1">{
                if x.ID == groupID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// AddGroup adds one or more command groups to this parent command.
func (c *Command) AddGroup(groups ...*Group) <span class="cov8" title="1">{
        c.commandgroups = append(c.commandgroups, groups...)
}</span>

// RemoveCommand removes one or more commands from a parent command.
func (c *Command) RemoveCommand(cmds ...*Command) <span class="cov8" title="1">{
        commands := []*Command{}
main:
        for _, command := range c.commands </span><span class="cov8" title="1">{
                for _, cmd := range cmds </span><span class="cov8" title="1">{
                        if command == cmd </span><span class="cov8" title="1">{
                                command.parent = nil
                                continue main</span>
                        }
                }
                <span class="cov8" title="1">commands = append(commands, command)</span>
        }
        <span class="cov8" title="1">c.commands = commands
        // recompute all lengths
        c.commandsMaxUseLen = 0
        c.commandsMaxCommandPathLen = 0
        c.commandsMaxNameLen = 0
        for _, command := range c.commands </span><span class="cov8" title="1">{
                usageLen := len(command.Use)
                if usageLen &gt; c.commandsMaxUseLen </span><span class="cov8" title="1">{
                        c.commandsMaxUseLen = usageLen
                }</span>
                <span class="cov8" title="1">commandPathLen := len(command.CommandPath())
                if commandPathLen &gt; c.commandsMaxCommandPathLen </span><span class="cov8" title="1">{
                        c.commandsMaxCommandPathLen = commandPathLen
                }</span>
                <span class="cov8" title="1">nameLen := len(command.Name())
                if nameLen &gt; c.commandsMaxNameLen </span><span class="cov8" title="1">{
                        c.commandsMaxNameLen = nameLen
                }</span>
        }
}

// Print is a convenience method to Print to the defined output, fallback to Stderr if not set.
func (c *Command) Print(i ...interface{}) <span class="cov8" title="1">{
        fmt.Fprint(c.OutOrStderr(), i...)
}</span>

// Println is a convenience method to Println to the defined output, fallback to Stderr if not set.
func (c *Command) Println(i ...interface{}) <span class="cov8" title="1">{
        c.Print(fmt.Sprintln(i...))
}</span>

// Printf is a convenience method to Printf to the defined output, fallback to Stderr if not set.
func (c *Command) Printf(format string, i ...interface{}) <span class="cov8" title="1">{
        c.Print(fmt.Sprintf(format, i...))
}</span>

// PrintErr is a convenience method to Print to the defined Err output, fallback to Stderr if not set.
func (c *Command) PrintErr(i ...interface{}) <span class="cov8" title="1">{
        fmt.Fprint(c.ErrOrStderr(), i...)
}</span>

// PrintErrln is a convenience method to Println to the defined Err output, fallback to Stderr if not set.
func (c *Command) PrintErrln(i ...interface{}) <span class="cov8" title="1">{
        c.PrintErr(fmt.Sprintln(i...))
}</span>

// PrintErrf is a convenience method to Printf to the defined Err output, fallback to Stderr if not set.
func (c *Command) PrintErrf(format string, i ...interface{}) <span class="cov8" title="1">{
        c.PrintErr(fmt.Sprintf(format, i...))
}</span>

// CommandPath returns the full path to this command.
func (c *Command) CommandPath() string <span class="cov8" title="1">{
        if c.HasParent() </span><span class="cov8" title="1">{
                return c.Parent().CommandPath() + " " + c.Name()
        }</span>
        <span class="cov8" title="1">return c.displayName()</span>
}

func (c *Command) displayName() string <span class="cov8" title="1">{
        if displayName, ok := c.Annotations[CommandDisplayNameAnnotation]; ok </span><span class="cov8" title="1">{
                return displayName
        }</span>
        <span class="cov8" title="1">return c.Name()</span>
}

// UseLine puts out the full usage for a given command (including parents).
func (c *Command) UseLine() string <span class="cov8" title="1">{
        var useline string
        use := strings.Replace(c.Use, c.Name(), c.displayName(), 1)
        if c.HasParent() </span><span class="cov8" title="1">{
                useline = c.parent.CommandPath() + " " + use
        }</span> else<span class="cov8" title="1"> {
                useline = use
        }</span>
        <span class="cov8" title="1">if c.DisableFlagsInUseLine </span><span class="cov0" title="0">{
                return useline
        }</span>
        <span class="cov8" title="1">if c.HasAvailableFlags() &amp;&amp; !strings.Contains(useline, "[flags]") </span><span class="cov8" title="1">{
                useline += " [flags]"
        }</span>
        <span class="cov8" title="1">return useline</span>
}

// DebugFlags used to determine which flags have been assigned to which commands
// and which persist.
func (c *Command) DebugFlags() <span class="cov0" title="0">{
        c.Println("DebugFlags called on", c.Name())
        var debugflags func(*Command)

        debugflags = func(x *Command) </span><span class="cov0" title="0">{
                if x.HasFlags() || x.HasPersistentFlags() </span><span class="cov0" title="0">{
                        c.Println(x.Name())
                }</span>
                <span class="cov0" title="0">if x.HasFlags() </span><span class="cov0" title="0">{
                        x.flags.VisitAll(func(f *flag.Flag) </span><span class="cov0" title="0">{
                                if x.HasPersistentFlags() &amp;&amp; x.persistentFlag(f.Name) != nil </span><span class="cov0" title="0">{
                                        c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [LP]")
                                }</span> else<span class="cov0" title="0"> {
                                        c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [L]")
                                }</span>
                        })
                }
                <span class="cov0" title="0">if x.HasPersistentFlags() </span><span class="cov0" title="0">{
                        x.pflags.VisitAll(func(f *flag.Flag) </span><span class="cov0" title="0">{
                                if x.HasFlags() </span><span class="cov0" title="0">{
                                        if x.flags.Lookup(f.Name) == nil </span><span class="cov0" title="0">{
                                                c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [P]")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [P]")
                                }</span>
                        })
                }
                <span class="cov0" title="0">c.Println(x.flagErrorBuf)
                if x.HasSubCommands() </span><span class="cov0" title="0">{
                        for _, y := range x.commands </span><span class="cov0" title="0">{
                                debugflags(y)
                        }</span>
                }
        }

        <span class="cov0" title="0">debugflags(c)</span>
}

// Name returns the command's name: the first word in the use line.
func (c *Command) Name() string <span class="cov8" title="1">{
        name := c.Use
        i := strings.Index(name, " ")
        if i &gt;= 0 </span><span class="cov8" title="1">{
                name = name[:i]
        }</span>
        <span class="cov8" title="1">return name</span>
}

// HasAlias determines if a given string is an alias of the command.
func (c *Command) HasAlias(s string) bool <span class="cov8" title="1">{
        for _, a := range c.Aliases </span><span class="cov8" title="1">{
                if commandNameMatches(a, s) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// CalledAs returns the command name or alias that was used to invoke
// this command or an empty string if the command has not been called.
func (c *Command) CalledAs() string <span class="cov8" title="1">{
        if c.commandCalledAs.called </span><span class="cov8" title="1">{
                return c.commandCalledAs.name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// hasNameOrAliasPrefix returns true if the Name or any of aliases start
// with prefix
func (c *Command) hasNameOrAliasPrefix(prefix string) bool <span class="cov8" title="1">{
        if strings.HasPrefix(c.Name(), prefix) </span><span class="cov8" title="1">{
                c.commandCalledAs.name = c.Name()
                return true
        }</span>
        <span class="cov8" title="1">for _, alias := range c.Aliases </span><span class="cov8" title="1">{
                if strings.HasPrefix(alias, prefix) </span><span class="cov8" title="1">{
                        c.commandCalledAs.name = alias
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// NameAndAliases returns a list of the command name and all aliases
func (c *Command) NameAndAliases() string <span class="cov0" title="0">{
        return strings.Join(append([]string{c.Name()}, c.Aliases...), ", ")
}</span>

// HasExample determines if the command has example.
func (c *Command) HasExample() bool <span class="cov8" title="1">{
        return len(c.Example) &gt; 0
}</span>

// Runnable determines if the command is itself runnable.
func (c *Command) Runnable() bool <span class="cov8" title="1">{
        return c.Run != nil || c.RunE != nil
}</span>

// HasSubCommands determines if the command has children commands.
func (c *Command) HasSubCommands() bool <span class="cov8" title="1">{
        return len(c.commands) &gt; 0
}</span>

// IsAvailableCommand determines if a command is available as a non-help command
// (this includes all non deprecated/hidden commands).
func (c *Command) IsAvailableCommand() bool <span class="cov8" title="1">{
        if len(c.Deprecated) != 0 || c.Hidden </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if c.HasParent() &amp;&amp; c.Parent().helpCommand == c </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if c.Runnable() || c.HasAvailableSubCommands() </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// IsAdditionalHelpTopicCommand determines if a command is an additional
// help topic command; additional help topic command is determined by the
// fact that it is NOT runnable/hidden/deprecated, and has no sub commands that
// are runnable/hidden/deprecated.
// Concrete example: https://github.com/spf13/cobra/issues/393#issuecomment-282741924.
func (c *Command) IsAdditionalHelpTopicCommand() bool <span class="cov8" title="1">{
        // if a command is runnable, deprecated, or hidden it is not a 'help' command
        if c.Runnable() || len(c.Deprecated) != 0 || c.Hidden </span><span class="cov8" title="1">{
                return false
        }</span>

        // if any non-help sub commands are found, the command is not a 'help' command
        <span class="cov8" title="1">for _, sub := range c.commands </span><span class="cov8" title="1">{
                if !sub.IsAdditionalHelpTopicCommand() </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // the command either has no sub commands, or no non-help sub commands
        <span class="cov8" title="1">return true</span>
}

// HasHelpSubCommands determines if a command has any available 'help' sub commands
// that need to be shown in the usage/help default template under 'additional help
// topics'.
func (c *Command) HasHelpSubCommands() bool <span class="cov8" title="1">{
        // return true on the first found available 'help' sub command
        for _, sub := range c.commands </span><span class="cov8" title="1">{
                if sub.IsAdditionalHelpTopicCommand() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // the command either has no sub commands, or no available 'help' sub commands
        <span class="cov8" title="1">return false</span>
}

// HasAvailableSubCommands determines if a command has available sub commands that
// need to be shown in the usage/help default template under 'available commands'.
func (c *Command) HasAvailableSubCommands() bool <span class="cov8" title="1">{
        // return true on the first found available (non deprecated/help/hidden)
        // sub command
        for _, sub := range c.commands </span><span class="cov8" title="1">{
                if sub.IsAvailableCommand() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // the command either has no sub commands, or no available (non deprecated/help/hidden)
        // sub commands
        <span class="cov8" title="1">return false</span>
}

// HasParent determines if the command is a child command.
func (c *Command) HasParent() bool <span class="cov8" title="1">{
        return c.parent != nil
}</span>

// GlobalNormalizationFunc returns the global normalization function or nil if it doesn't exist.
func (c *Command) GlobalNormalizationFunc() func(f *flag.FlagSet, name string) flag.NormalizedName <span class="cov8" title="1">{
        return c.globNormFunc
}</span>

// Flags returns the complete FlagSet that applies
// to this command (local and persistent declared here and by all parents).
func (c *Command) Flags() *flag.FlagSet <span class="cov8" title="1">{
        if c.flags == nil </span><span class="cov8" title="1">{
                c.flags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
                if c.flagErrorBuf == nil </span><span class="cov8" title="1">{
                        c.flagErrorBuf = new(bytes.Buffer)
                }</span>
                <span class="cov8" title="1">c.flags.SetOutput(c.flagErrorBuf)</span>
        }

        <span class="cov8" title="1">return c.flags</span>
}

// LocalNonPersistentFlags are flags specific to this command which will NOT persist to subcommands.
// This function does not modify the flags of the current command, it's purpose is to return the current state.
func (c *Command) LocalNonPersistentFlags() *flag.FlagSet <span class="cov8" title="1">{
        persistentFlags := c.PersistentFlags()

        out := flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
        c.LocalFlags().VisitAll(func(f *flag.Flag) </span><span class="cov8" title="1">{
                if persistentFlags.Lookup(f.Name) == nil </span><span class="cov8" title="1">{
                        out.AddFlag(f)
                }</span>
        })
        <span class="cov8" title="1">return out</span>
}

// LocalFlags returns the local FlagSet specifically set in the current command.
// This function does not modify the flags of the current command, it's purpose is to return the current state.
func (c *Command) LocalFlags() *flag.FlagSet <span class="cov8" title="1">{
        c.mergePersistentFlags()

        if c.lflags == nil </span><span class="cov8" title="1">{
                c.lflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
                if c.flagErrorBuf == nil </span><span class="cov0" title="0">{
                        c.flagErrorBuf = new(bytes.Buffer)
                }</span>
                <span class="cov8" title="1">c.lflags.SetOutput(c.flagErrorBuf)</span>
        }
        <span class="cov8" title="1">c.lflags.SortFlags = c.Flags().SortFlags
        if c.globNormFunc != nil </span><span class="cov8" title="1">{
                c.lflags.SetNormalizeFunc(c.globNormFunc)
        }</span>

        <span class="cov8" title="1">addToLocal := func(f *flag.Flag) </span><span class="cov8" title="1">{
                // Add the flag if it is not a parent PFlag, or it shadows a parent PFlag
                if c.lflags.Lookup(f.Name) == nil &amp;&amp; f != c.parentsPflags.Lookup(f.Name) </span><span class="cov8" title="1">{
                        c.lflags.AddFlag(f)
                }</span>
        }
        <span class="cov8" title="1">c.Flags().VisitAll(addToLocal)
        c.PersistentFlags().VisitAll(addToLocal)
        return c.lflags</span>
}

// InheritedFlags returns all flags which were inherited from parent commands.
// This function does not modify the flags of the current command, it's purpose is to return the current state.
func (c *Command) InheritedFlags() *flag.FlagSet <span class="cov8" title="1">{
        c.mergePersistentFlags()

        if c.iflags == nil </span><span class="cov8" title="1">{
                c.iflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
                if c.flagErrorBuf == nil </span><span class="cov0" title="0">{
                        c.flagErrorBuf = new(bytes.Buffer)
                }</span>
                <span class="cov8" title="1">c.iflags.SetOutput(c.flagErrorBuf)</span>
        }

        <span class="cov8" title="1">local := c.LocalFlags()
        if c.globNormFunc != nil </span><span class="cov8" title="1">{
                c.iflags.SetNormalizeFunc(c.globNormFunc)
        }</span>

        <span class="cov8" title="1">c.parentsPflags.VisitAll(func(f *flag.Flag) </span><span class="cov8" title="1">{
                if c.iflags.Lookup(f.Name) == nil &amp;&amp; local.Lookup(f.Name) == nil </span><span class="cov8" title="1">{
                        c.iflags.AddFlag(f)
                }</span>
        })
        <span class="cov8" title="1">return c.iflags</span>
}

// NonInheritedFlags returns all flags which were not inherited from parent commands.
// This function does not modify the flags of the current command, it's purpose is to return the current state.
func (c *Command) NonInheritedFlags() *flag.FlagSet <span class="cov8" title="1">{
        return c.LocalFlags()
}</span>

// PersistentFlags returns the persistent FlagSet specifically set in the current command.
func (c *Command) PersistentFlags() *flag.FlagSet <span class="cov8" title="1">{
        if c.pflags == nil </span><span class="cov8" title="1">{
                c.pflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
                if c.flagErrorBuf == nil </span><span class="cov8" title="1">{
                        c.flagErrorBuf = new(bytes.Buffer)
                }</span>
                <span class="cov8" title="1">c.pflags.SetOutput(c.flagErrorBuf)</span>
        }
        <span class="cov8" title="1">return c.pflags</span>
}

// ResetFlags deletes all flags from command.
func (c *Command) ResetFlags() <span class="cov0" title="0">{
        c.flagErrorBuf = new(bytes.Buffer)
        c.flagErrorBuf.Reset()
        c.flags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
        c.flags.SetOutput(c.flagErrorBuf)
        c.pflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
        c.pflags.SetOutput(c.flagErrorBuf)

        c.lflags = nil
        c.iflags = nil
        c.parentsPflags = nil
}</span>

// HasFlags checks if the command contains any flags (local plus persistent from the entire structure).
func (c *Command) HasFlags() bool <span class="cov0" title="0">{
        return c.Flags().HasFlags()
}</span>

// HasPersistentFlags checks if the command contains persistent flags.
func (c *Command) HasPersistentFlags() bool <span class="cov8" title="1">{
        return c.PersistentFlags().HasFlags()
}</span>

// HasLocalFlags checks if the command has flags specifically declared locally.
func (c *Command) HasLocalFlags() bool <span class="cov0" title="0">{
        return c.LocalFlags().HasFlags()
}</span>

// HasInheritedFlags checks if the command has flags inherited from its parent command.
func (c *Command) HasInheritedFlags() bool <span class="cov0" title="0">{
        return c.InheritedFlags().HasFlags()
}</span>

// HasAvailableFlags checks if the command contains any flags (local plus persistent from the entire
// structure) which are not hidden or deprecated.
func (c *Command) HasAvailableFlags() bool <span class="cov8" title="1">{
        return c.Flags().HasAvailableFlags()
}</span>

// HasAvailablePersistentFlags checks if the command contains persistent flags which are not hidden or deprecated.
func (c *Command) HasAvailablePersistentFlags() bool <span class="cov0" title="0">{
        return c.PersistentFlags().HasAvailableFlags()
}</span>

// HasAvailableLocalFlags checks if the command has flags specifically declared locally which are not hidden
// or deprecated.
func (c *Command) HasAvailableLocalFlags() bool <span class="cov8" title="1">{
        return c.LocalFlags().HasAvailableFlags()
}</span>

// HasAvailableInheritedFlags checks if the command has flags inherited from its parent command which are
// not hidden or deprecated.
func (c *Command) HasAvailableInheritedFlags() bool <span class="cov8" title="1">{
        return c.InheritedFlags().HasAvailableFlags()
}</span>

// Flag climbs up the command tree looking for matching flag.
func (c *Command) Flag(name string) (flag *flag.Flag) <span class="cov8" title="1">{
        flag = c.Flags().Lookup(name)

        if flag == nil </span><span class="cov8" title="1">{
                flag = c.persistentFlag(name)
        }</span>

        <span class="cov8" title="1">return</span>
}

// Recursively find matching persistent flag.
func (c *Command) persistentFlag(name string) (flag *flag.Flag) <span class="cov8" title="1">{
        if c.HasPersistentFlags() </span><span class="cov8" title="1">{
                flag = c.PersistentFlags().Lookup(name)
        }</span>

        <span class="cov8" title="1">if flag == nil </span><span class="cov8" title="1">{
                c.updateParentsPflags()
                flag = c.parentsPflags.Lookup(name)
        }</span>
        <span class="cov8" title="1">return</span>
}

// ParseFlags parses persistent flag tree and local flags.
func (c *Command) ParseFlags(args []string) error <span class="cov8" title="1">{
        if c.DisableFlagParsing </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if c.flagErrorBuf == nil </span><span class="cov8" title="1">{
                c.flagErrorBuf = new(bytes.Buffer)
        }</span>
        <span class="cov8" title="1">beforeErrorBufLen := c.flagErrorBuf.Len()
        c.mergePersistentFlags()

        // do it here after merging all flags and just before parse
        c.Flags().ParseErrorsWhitelist = flag.ParseErrorsWhitelist(c.FParseErrWhitelist)

        err := c.Flags().Parse(args)
        // Print warnings if they occurred (e.g. deprecated flag messages).
        if c.flagErrorBuf.Len()-beforeErrorBufLen &gt; 0 &amp;&amp; err == nil </span><span class="cov8" title="1">{
                c.Print(c.flagErrorBuf.String())
        }</span>

        <span class="cov8" title="1">return err</span>
}

// Parent returns a commands parent command.
func (c *Command) Parent() *Command <span class="cov8" title="1">{
        return c.parent
}</span>

// mergePersistentFlags merges c.PersistentFlags() to c.Flags()
// and adds missing persistent flags of all parents.
func (c *Command) mergePersistentFlags() <span class="cov8" title="1">{
        c.updateParentsPflags()
        c.Flags().AddFlagSet(c.PersistentFlags())
        c.Flags().AddFlagSet(c.parentsPflags)
}</span>

// updateParentsPflags updates c.parentsPflags by adding
// new persistent flags of all parents.
// If c.parentsPflags == nil, it makes new.
func (c *Command) updateParentsPflags() <span class="cov8" title="1">{
        if c.parentsPflags == nil </span><span class="cov8" title="1">{
                c.parentsPflags = flag.NewFlagSet(c.displayName(), flag.ContinueOnError)
                c.parentsPflags.SetOutput(c.flagErrorBuf)
                c.parentsPflags.SortFlags = false
        }</span>

        <span class="cov8" title="1">if c.globNormFunc != nil </span><span class="cov8" title="1">{
                c.parentsPflags.SetNormalizeFunc(c.globNormFunc)
        }</span>

        <span class="cov8" title="1">c.Root().PersistentFlags().AddFlagSet(flag.CommandLine)

        c.VisitParents(func(parent *Command) </span><span class="cov8" title="1">{
                c.parentsPflags.AddFlagSet(parent.PersistentFlags())
        }</span>)
}

// commandNameMatches checks if two command names are equal
// taking into account case sensitivity according to
// EnableCaseInsensitive global configuration.
func commandNameMatches(s string, t string) bool <span class="cov8" title="1">{
        if EnableCaseInsensitive </span><span class="cov8" title="1">{
                return strings.EqualFold(s, t)
        }</span>

        <span class="cov8" title="1">return s == t</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"
        "sync"

        "github.com/spf13/pflag"
)

const (
        // ShellCompRequestCmd is the name of the hidden command that is used to request
        // completion results from the program.  It is used by the shell completion scripts.
        ShellCompRequestCmd = "__complete"
        // ShellCompNoDescRequestCmd is the name of the hidden command that is used to request
        // completion results without their description.  It is used by the shell completion scripts.
        ShellCompNoDescRequestCmd = "__completeNoDesc"
)

// Global map of flag completion functions. Make sure to use flagCompletionMutex before you try to read and write from it.
var flagCompletionFunctions = map[*pflag.Flag]func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective){}

// lock for reading and writing from flagCompletionFunctions
var flagCompletionMutex = &amp;sync.RWMutex{}

// ShellCompDirective is a bit map representing the different behaviors the shell
// can be instructed to have once completions have been provided.
type ShellCompDirective int

type flagCompError struct {
        subCommand string
        flagName   string
}

func (e *flagCompError) Error() string <span class="cov0" title="0">{
        return "Subcommand '" + e.subCommand + "' does not support flag '" + e.flagName + "'"
}</span>

const (
        // ShellCompDirectiveError indicates an error occurred and completions should be ignored.
        ShellCompDirectiveError ShellCompDirective = 1 &lt;&lt; iota

        // ShellCompDirectiveNoSpace indicates that the shell should not add a space
        // after the completion even if there is a single completion provided.
        ShellCompDirectiveNoSpace

        // ShellCompDirectiveNoFileComp indicates that the shell should not provide
        // file completion even when no completion is provided.
        ShellCompDirectiveNoFileComp

        // ShellCompDirectiveFilterFileExt indicates that the provided completions
        // should be used as file extension filters.
        // For flags, using Command.MarkFlagFilename() and Command.MarkPersistentFlagFilename()
        // is a shortcut to using this directive explicitly.  The BashCompFilenameExt
        // annotation can also be used to obtain the same behavior for flags.
        ShellCompDirectiveFilterFileExt

        // ShellCompDirectiveFilterDirs indicates that only directory names should
        // be provided in file completion.  To request directory names within another
        // directory, the returned completions should specify the directory within
        // which to search.  The BashCompSubdirsInDir annotation can be used to
        // obtain the same behavior but only for flags.
        ShellCompDirectiveFilterDirs

        // ShellCompDirectiveKeepOrder indicates that the shell should preserve the order
        // in which the completions are provided
        ShellCompDirectiveKeepOrder

        // ===========================================================================

        // All directives using iota should be above this one.
        // For internal use.
        shellCompDirectiveMaxValue

        // ShellCompDirectiveDefault indicates to let the shell perform its default
        // behavior after completions have been provided.
        // This one must be last to avoid messing up the iota count.
        ShellCompDirectiveDefault ShellCompDirective = 0
)

const (
        // Constants for the completion command
        compCmdName              = "completion"
        compCmdNoDescFlagName    = "no-descriptions"
        compCmdNoDescFlagDesc    = "disable completion descriptions"
        compCmdNoDescFlagDefault = false
)

// CompletionOptions are the options to control shell completion
type CompletionOptions struct {
        // DisableDefaultCmd prevents Cobra from creating a default 'completion' command
        DisableDefaultCmd bool
        // DisableNoDescFlag prevents Cobra from creating the '--no-descriptions' flag
        // for shells that support completion descriptions
        DisableNoDescFlag bool
        // DisableDescriptions turns off all completion descriptions for shells
        // that support them
        DisableDescriptions bool
        // HiddenDefaultCmd makes the default 'completion' command hidden
        HiddenDefaultCmd bool
}

// NoFileCompletions can be used to disable file completion for commands that should
// not trigger file completions.
func NoFileCompletions(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) <span class="cov8" title="1">{
        return nil, ShellCompDirectiveNoFileComp
}</span>

// FixedCompletions can be used to create a completion function which always
// returns the same results.
func FixedCompletions(choices []string, directive ShellCompDirective) func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) <span class="cov8" title="1">{
        return func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective) </span><span class="cov8" title="1">{
                return choices, directive
        }</span>
}

// RegisterFlagCompletionFunc should be called to register a function to provide completion for a flag.
func (c *Command) RegisterFlagCompletionFunc(flagName string, f func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)) error <span class="cov8" title="1">{
        flag := c.Flag(flagName)
        if flag == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterFlagCompletionFunc: flag '%s' does not exist", flagName)
        }</span>
        <span class="cov8" title="1">flagCompletionMutex.Lock()
        defer flagCompletionMutex.Unlock()

        if _, exists := flagCompletionFunctions[flag]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("RegisterFlagCompletionFunc: flag '%s' already registered", flagName)
        }</span>
        <span class="cov8" title="1">flagCompletionFunctions[flag] = f
        return nil</span>
}

// GetFlagCompletionFunc returns the completion function for the given flag of the command, if available.
func (c *Command) GetFlagCompletionFunc(flagName string) (func(*Command, []string, string) ([]string, ShellCompDirective), bool) <span class="cov8" title="1">{
        flag := c.Flag(flagName)
        if flag == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">flagCompletionMutex.RLock()
        defer flagCompletionMutex.RUnlock()

        completionFunc, exists := flagCompletionFunctions[flag]
        return completionFunc, exists</span>
}

// Returns a string listing the different directive enabled in the specified parameter
func (d ShellCompDirective) string() string <span class="cov8" title="1">{
        var directives []string
        if d&amp;ShellCompDirectiveError != 0 </span><span class="cov0" title="0">{
                directives = append(directives, "ShellCompDirectiveError")
        }</span>
        <span class="cov8" title="1">if d&amp;ShellCompDirectiveNoSpace != 0 </span><span class="cov8" title="1">{
                directives = append(directives, "ShellCompDirectiveNoSpace")
        }</span>
        <span class="cov8" title="1">if d&amp;ShellCompDirectiveNoFileComp != 0 </span><span class="cov8" title="1">{
                directives = append(directives, "ShellCompDirectiveNoFileComp")
        }</span>
        <span class="cov8" title="1">if d&amp;ShellCompDirectiveFilterFileExt != 0 </span><span class="cov8" title="1">{
                directives = append(directives, "ShellCompDirectiveFilterFileExt")
        }</span>
        <span class="cov8" title="1">if d&amp;ShellCompDirectiveFilterDirs != 0 </span><span class="cov8" title="1">{
                directives = append(directives, "ShellCompDirectiveFilterDirs")
        }</span>
        <span class="cov8" title="1">if d&amp;ShellCompDirectiveKeepOrder != 0 </span><span class="cov0" title="0">{
                directives = append(directives, "ShellCompDirectiveKeepOrder")
        }</span>
        <span class="cov8" title="1">if len(directives) == 0 </span><span class="cov8" title="1">{
                directives = append(directives, "ShellCompDirectiveDefault")
        }</span>

        <span class="cov8" title="1">if d &gt;= shellCompDirectiveMaxValue </span><span class="cov0" title="0">{
                return fmt.Sprintf("ERROR: unexpected ShellCompDirective value: %d", d)
        }</span>
        <span class="cov8" title="1">return strings.Join(directives, ", ")</span>
}

// initCompleteCmd adds a special hidden command that can be used to request custom completions.
func (c *Command) initCompleteCmd(args []string) <span class="cov8" title="1">{
        completeCmd := &amp;Command{
                Use:                   fmt.Sprintf("%s [command-line]", ShellCompRequestCmd),
                Aliases:               []string{ShellCompNoDescRequestCmd},
                DisableFlagsInUseLine: true,
                Hidden:                true,
                DisableFlagParsing:    true,
                Args:                  MinimumNArgs(1),
                Short:                 "Request shell completion choices for the specified command-line",
                Long: fmt.Sprintf("%[2]s is a special command that is used by the shell completion logic\n%[1]s",
                        "to request completion choices for the specified command-line.", ShellCompRequestCmd),
                Run: func(cmd *Command, args []string) </span><span class="cov8" title="1">{
                        finalCmd, completions, directive, err := cmd.getCompletions(args)
                        if err != nil </span><span class="cov8" title="1">{
                                CompErrorln(err.Error())
                                // Keep going for multiple reasons:
                                // 1- There could be some valid completions even though there was an error
                                // 2- Even without completions, we need to print the directive
                        }</span>

                        <span class="cov8" title="1">noDescriptions := cmd.CalledAs() == ShellCompNoDescRequestCmd
                        if !noDescriptions </span><span class="cov8" title="1">{
                                if doDescriptions, err := strconv.ParseBool(getEnvConfig(cmd, configEnvVarSuffixDescriptions)); err == nil </span><span class="cov8" title="1">{
                                        noDescriptions = !doDescriptions
                                }</span>
                        }
                        <span class="cov8" title="1">noActiveHelp := GetActiveHelpConfig(finalCmd) == activeHelpGlobalDisable
                        out := finalCmd.OutOrStdout()
                        for _, comp := range completions </span><span class="cov8" title="1">{
                                if noActiveHelp &amp;&amp; strings.HasPrefix(comp, activeHelpMarker) </span><span class="cov8" title="1">{
                                        // Remove all activeHelp entries if it's disabled.
                                        continue</span>
                                }
                                <span class="cov8" title="1">if noDescriptions </span><span class="cov8" title="1">{
                                        // Remove any description that may be included following a tab character.
                                        comp = strings.SplitN(comp, "\t", 2)[0]
                                }</span>

                                // Make sure we only write the first line to the output.
                                // This is needed if a description contains a linebreak.
                                // Otherwise the shell scripts will interpret the other lines as new flags
                                // and could therefore provide a wrong completion.
                                <span class="cov8" title="1">comp = strings.SplitN(comp, "\n", 2)[0]

                                // Finally trim the completion.  This is especially important to get rid
                                // of a trailing tab when there are no description following it.
                                // For example, a sub-command without a description should not be completed
                                // with a tab at the end (or else zsh will show a -- following it
                                // although there is no description).
                                comp = strings.TrimSpace(comp)

                                // Print each possible completion to the output for the completion script to consume.
                                fmt.Fprintln(out, comp)</span>
                        }

                        // As the last printout, print the completion directive for the completion script to parse.
                        // The directive integer must be that last character following a single colon (:).
                        // The completion script expects :&lt;directive&gt;
                        <span class="cov8" title="1">fmt.Fprintf(out, ":%d\n", directive)

                        // Print some helpful info to stderr for the user to understand.
                        // Output from stderr must be ignored by the completion script.
                        fmt.Fprintf(finalCmd.ErrOrStderr(), "Completion ended with directive: %s\n", directive.string())</span>
                },
        }
        <span class="cov8" title="1">c.AddCommand(completeCmd)
        subCmd, _, err := c.Find(args)
        if err != nil || subCmd.Name() != ShellCompRequestCmd </span><span class="cov8" title="1">{
                // Only create this special command if it is actually being called.
                // This reduces possible side-effects of creating such a command;
                // for example, having this command would cause problems to a
                // cobra program that only consists of the root command, since this
                // command would cause the root command to suddenly have a subcommand.
                c.RemoveCommand(completeCmd)
        }</span>
}

func (c *Command) getCompletions(args []string) (*Command, []string, ShellCompDirective, error) <span class="cov8" title="1">{
        // The last argument, which is not completely typed by the user,
        // should not be part of the list of arguments
        toComplete := args[len(args)-1]
        trimmedArgs := args[:len(args)-1]

        var finalCmd *Command
        var finalArgs []string
        var err error
        // Find the real command for which completion must be performed
        // check if we need to traverse here to parse local flags on parent commands
        if c.Root().TraverseChildren </span><span class="cov8" title="1">{
                finalCmd, finalArgs, err = c.Root().Traverse(trimmedArgs)
        }</span> else<span class="cov8" title="1"> {
                // For Root commands that don't specify any value for their Args fields, when we call
                // Find(), if those Root commands don't have any sub-commands, they will accept arguments.
                // However, because we have added the __complete sub-command in the current code path, the
                // call to Find() -&gt; legacyArgs() will return an error if there are any arguments.
                // To avoid this, we first remove the __complete command to get back to having no sub-commands.
                rootCmd := c.Root()
                if len(rootCmd.Commands()) == 1 </span><span class="cov8" title="1">{
                        rootCmd.RemoveCommand(c)
                }</span>

                <span class="cov8" title="1">finalCmd, finalArgs, err = rootCmd.Find(trimmedArgs)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // Unable to find the real command. E.g., &lt;program&gt; someInvalidCmd &lt;TAB&gt;
                return c, []string{}, ShellCompDirectiveDefault, fmt.Errorf("unable to find a command for arguments: %v", trimmedArgs)
        }</span>
        <span class="cov8" title="1">finalCmd.ctx = c.ctx

        // These flags are normally added when `execute()` is called on `finalCmd`,
        // however, when doing completion, we don't call `finalCmd.execute()`.
        // Let's add the --help and --version flag ourselves but only if the finalCmd
        // has not disabled flag parsing; if flag parsing is disabled, it is up to the
        // finalCmd itself to handle the completion of *all* flags.
        if !finalCmd.DisableFlagParsing </span><span class="cov8" title="1">{
                finalCmd.InitDefaultHelpFlag()
                finalCmd.InitDefaultVersionFlag()
        }</span>

        // Check if we are doing flag value completion before parsing the flags.
        // This is important because if we are completing a flag value, we need to also
        // remove the flag name argument from the list of finalArgs or else the parsing
        // could fail due to an invalid value (incomplete) for the flag.
        <span class="cov8" title="1">flag, finalArgs, toComplete, flagErr := checkIfFlagCompletion(finalCmd, finalArgs, toComplete)

        // Check if interspersed is false or -- was set on a previous arg.
        // This works by counting the arguments. Normally -- is not counted as arg but
        // if -- was already set or interspersed is false and there is already one arg then
        // the extra added -- is counted as arg.
        flagCompletion := true
        _ = finalCmd.ParseFlags(append(finalArgs, "--"))
        newArgCount := finalCmd.Flags().NArg()

        // Parse the flags early so we can check if required flags are set
        if err = finalCmd.ParseFlags(finalArgs); err != nil </span><span class="cov8" title="1">{
                return finalCmd, []string{}, ShellCompDirectiveDefault, fmt.Errorf("Error while parsing flags from args %v: %s", finalArgs, err.Error())
        }</span>

        <span class="cov8" title="1">realArgCount := finalCmd.Flags().NArg()
        if newArgCount &gt; realArgCount </span><span class="cov8" title="1">{
                // don't do flag completion (see above)
                flagCompletion = false
        }</span>
        // Error while attempting to parse flags
        <span class="cov8" title="1">if flagErr != nil </span><span class="cov8" title="1">{
                // If error type is flagCompError and we don't want flagCompletion we should ignore the error
                if _, ok := flagErr.(*flagCompError); !(ok &amp;&amp; !flagCompletion) </span><span class="cov0" title="0">{
                        return finalCmd, []string{}, ShellCompDirectiveDefault, flagErr
                }</span>
        }

        // Look for the --help or --version flags.  If they are present,
        // there should be no further completions.
        <span class="cov8" title="1">if helpOrVersionFlagPresent(finalCmd) </span><span class="cov8" title="1">{
                return finalCmd, []string{}, ShellCompDirectiveNoFileComp, nil
        }</span>

        // We only remove the flags from the arguments if DisableFlagParsing is not set.
        // This is important for commands which have requested to do their own flag completion.
        <span class="cov8" title="1">if !finalCmd.DisableFlagParsing </span><span class="cov8" title="1">{
                finalArgs = finalCmd.Flags().Args()
        }</span>

        <span class="cov8" title="1">if flag != nil &amp;&amp; flagCompletion </span><span class="cov8" title="1">{
                // Check if we are completing a flag value subject to annotations
                if validExts, present := flag.Annotations[BashCompFilenameExt]; present </span><span class="cov8" title="1">{
                        if len(validExts) != 0 </span><span class="cov8" title="1">{
                                // File completion filtered by extensions
                                return finalCmd, validExts, ShellCompDirectiveFilterFileExt, nil
                        }</span>

                        // The annotation requests simple file completion.  There is no reason to do
                        // that since it is the default behavior anyway.  Let's ignore this annotation
                        // in case the program also registered a completion function for this flag.
                        // Even though it is a mistake on the program's side, let's be nice when we can.
                }

                <span class="cov8" title="1">if subDir, present := flag.Annotations[BashCompSubdirsInDir]; present </span><span class="cov8" title="1">{
                        if len(subDir) == 1 </span><span class="cov8" title="1">{
                                // Directory completion from within a directory
                                return finalCmd, subDir, ShellCompDirectiveFilterDirs, nil
                        }</span>
                        // Directory completion
                        <span class="cov8" title="1">return finalCmd, []string{}, ShellCompDirectiveFilterDirs, nil</span>
                }
        }

        <span class="cov8" title="1">var completions []string
        var directive ShellCompDirective

        // Enforce flag groups before doing flag completions
        finalCmd.enforceFlagGroupsForCompletion()

        // Note that we want to perform flagname completion even if finalCmd.DisableFlagParsing==true;
        // doing this allows for completion of persistent flag names even for commands that disable flag parsing.
        //
        // When doing completion of a flag name, as soon as an argument starts with
        // a '-' we know it is a flag.  We cannot use isFlagArg() here as it requires
        // the flag name to be complete
        if flag == nil &amp;&amp; len(toComplete) &gt; 0 &amp;&amp; toComplete[0] == '-' &amp;&amp; !strings.Contains(toComplete, "=") &amp;&amp; flagCompletion </span><span class="cov8" title="1">{
                // First check for required flags
                completions = completeRequireFlags(finalCmd, toComplete)

                // If we have not found any required flags, only then can we show regular flags
                if len(completions) == 0 </span><span class="cov8" title="1">{
                        doCompleteFlags := func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                                if !flag.Changed ||
                                        strings.Contains(flag.Value.Type(), "Slice") ||
                                        strings.Contains(flag.Value.Type(), "Array") </span><span class="cov8" title="1">{
                                        // If the flag is not already present, or if it can be specified multiple times (Array or Slice)
                                        // we suggest it as a completion
                                        completions = append(completions, getFlagNameCompletions(flag, toComplete)...)
                                }</span>
                        }

                        // We cannot use finalCmd.Flags() because we may not have called ParsedFlags() for commands
                        // that have set DisableFlagParsing; it is ParseFlags() that merges the inherited and
                        // non-inherited flags.
                        <span class="cov8" title="1">finalCmd.InheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                                doCompleteFlags(flag)
                        }</span>)
                        // Try to complete non-inherited flags even if DisableFlagParsing==true.
                        // This allows programs to tell Cobra about flags for completion even
                        // if the actual parsing of flags is not done by Cobra.
                        // For instance, Helm uses this to provide flag name completion for
                        // some of its plugins.
                        <span class="cov8" title="1">finalCmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                                doCompleteFlags(flag)
                        }</span>)
                }

                <span class="cov8" title="1">directive = ShellCompDirectiveNoFileComp
                if len(completions) == 1 &amp;&amp; strings.HasSuffix(completions[0], "=") </span><span class="cov0" title="0">{
                        // If there is a single completion, the shell usually adds a space
                        // after the completion.  We don't want that if the flag ends with an =
                        directive = ShellCompDirectiveNoSpace
                }</span>

                <span class="cov8" title="1">if !finalCmd.DisableFlagParsing </span><span class="cov8" title="1">{
                        // If DisableFlagParsing==false, we have completed the flags as known by Cobra;
                        // we can return what we found.
                        // If DisableFlagParsing==true, Cobra may not be aware of all flags, so we
                        // let the logic continue to see if ValidArgsFunction needs to be called.
                        return finalCmd, completions, directive, nil
                }</span>
        } else<span class="cov8" title="1"> {
                directive = ShellCompDirectiveDefault
                if flag == nil </span><span class="cov8" title="1">{
                        foundLocalNonPersistentFlag := false
                        // If TraverseChildren is true on the root command we don't check for
                        // local flags because we can use a local flag on a parent command
                        if !finalCmd.Root().TraverseChildren </span><span class="cov8" title="1">{
                                // Check if there are any local, non-persistent flags on the command-line
                                localNonPersistentFlags := finalCmd.LocalNonPersistentFlags()
                                finalCmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                                        if localNonPersistentFlags.Lookup(flag.Name) != nil &amp;&amp; flag.Changed </span><span class="cov8" title="1">{
                                                foundLocalNonPersistentFlag = true
                                        }</span>
                                })
                        }

                        // Complete subcommand names, including the help command
                        <span class="cov8" title="1">if len(finalArgs) == 0 &amp;&amp; !foundLocalNonPersistentFlag </span><span class="cov8" title="1">{
                                // We only complete sub-commands if:
                                // - there are no arguments on the command-line and
                                // - there are no local, non-persistent flags on the command-line or TraverseChildren is true
                                for _, subCmd := range finalCmd.Commands() </span><span class="cov8" title="1">{
                                        if subCmd.IsAvailableCommand() || subCmd == finalCmd.helpCommand </span><span class="cov8" title="1">{
                                                if strings.HasPrefix(subCmd.Name(), toComplete) </span><span class="cov8" title="1">{
                                                        completions = append(completions, fmt.Sprintf("%s\t%s", subCmd.Name(), subCmd.Short))
                                                }</span>
                                                <span class="cov8" title="1">directive = ShellCompDirectiveNoFileComp</span>
                                        }
                                }
                        }

                        // Complete required flags even without the '-' prefix
                        <span class="cov8" title="1">completions = append(completions, completeRequireFlags(finalCmd, toComplete)...)

                        // Always complete ValidArgs, even if we are completing a subcommand name.
                        // This is for commands that have both subcommands and ValidArgs.
                        if len(finalCmd.ValidArgs) &gt; 0 </span><span class="cov8" title="1">{
                                if len(finalArgs) == 0 </span><span class="cov8" title="1">{
                                        // ValidArgs are only for the first argument
                                        for _, validArg := range finalCmd.ValidArgs </span><span class="cov8" title="1">{
                                                if strings.HasPrefix(validArg, toComplete) </span><span class="cov8" title="1">{
                                                        completions = append(completions, validArg)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">directive = ShellCompDirectiveNoFileComp

                                        // If no completions were found within commands or ValidArgs,
                                        // see if there are any ArgAliases that should be completed.
                                        if len(completions) == 0 </span><span class="cov8" title="1">{
                                                for _, argAlias := range finalCmd.ArgAliases </span><span class="cov8" title="1">{
                                                        if strings.HasPrefix(argAlias, toComplete) </span><span class="cov8" title="1">{
                                                                completions = append(completions, argAlias)
                                                        }</span>
                                                }
                                        }
                                }

                                // If there are ValidArgs specified (even if they don't match), we stop completion.
                                // Only one of ValidArgs or ValidArgsFunction can be used for a single command.
                                <span class="cov8" title="1">return finalCmd, completions, directive, nil</span>
                        }

                        // Let the logic continue so as to add any ValidArgsFunction completions,
                        // even if we already found sub-commands.
                        // This is for commands that have subcommands but also specify a ValidArgsFunction.
                }
        }

        // Find the completion function for the flag or command
        <span class="cov8" title="1">var completionFn func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)
        if flag != nil &amp;&amp; flagCompletion </span><span class="cov8" title="1">{
                flagCompletionMutex.RLock()
                completionFn = flagCompletionFunctions[flag]
                flagCompletionMutex.RUnlock()
        }</span> else<span class="cov8" title="1"> {
                completionFn = finalCmd.ValidArgsFunction
        }</span>
        <span class="cov8" title="1">if completionFn != nil </span><span class="cov8" title="1">{
                // Go custom completion defined for this flag or command.
                // Call the registered completion function to get the completions.
                var comps []string
                comps, directive = completionFn(finalCmd, finalArgs, toComplete)
                completions = append(completions, comps...)
        }</span>

        <span class="cov8" title="1">return finalCmd, completions, directive, nil</span>
}

func helpOrVersionFlagPresent(cmd *Command) bool <span class="cov8" title="1">{
        if versionFlag := cmd.Flags().Lookup("version"); versionFlag != nil &amp;&amp;
                len(versionFlag.Annotations[FlagSetByCobraAnnotation]) &gt; 0 &amp;&amp; versionFlag.Changed </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if helpFlag := cmd.Flags().Lookup("help"); helpFlag != nil &amp;&amp;
                len(helpFlag.Annotations[FlagSetByCobraAnnotation]) &gt; 0 &amp;&amp; helpFlag.Changed </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func getFlagNameCompletions(flag *pflag.Flag, toComplete string) []string <span class="cov8" title="1">{
        if nonCompletableFlag(flag) </span><span class="cov8" title="1">{
                return []string{}
        }</span>

        <span class="cov8" title="1">var completions []string
        flagName := "--" + flag.Name
        if strings.HasPrefix(flagName, toComplete) </span><span class="cov8" title="1">{
                // Flag without the =
                completions = append(completions, fmt.Sprintf("%s\t%s", flagName, flag.Usage))

                // Why suggest both long forms: --flag and --flag= ?
                // This forces the user to *always* have to type either an = or a space after the flag name.
                // Let's be nice and avoid making users have to do that.
                // Since boolean flags and shortname flags don't show the = form, let's go that route and never show it.
                // The = form will still work, we just won't suggest it.
                // This also makes the list of suggested flags shorter as we avoid all the = forms.
                //
                // if len(flag.NoOptDefVal) == 0 {
                //         // Flag requires a value, so it can be suffixed with =
                //         flagName += "="
                //         completions = append(completions, fmt.Sprintf("%s\t%s", flagName, flag.Usage))
                // }
        }</span>

        <span class="cov8" title="1">flagName = "-" + flag.Shorthand
        if len(flag.Shorthand) &gt; 0 &amp;&amp; strings.HasPrefix(flagName, toComplete) </span><span class="cov8" title="1">{
                completions = append(completions, fmt.Sprintf("%s\t%s", flagName, flag.Usage))
        }</span>

        <span class="cov8" title="1">return completions</span>
}

func completeRequireFlags(finalCmd *Command, toComplete string) []string <span class="cov8" title="1">{
        var completions []string

        doCompleteRequiredFlags := func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                if _, present := flag.Annotations[BashCompOneRequiredFlag]; present </span><span class="cov8" title="1">{
                        if !flag.Changed </span><span class="cov8" title="1">{
                                // If the flag is not already present, we suggest it as a completion
                                completions = append(completions, getFlagNameCompletions(flag, toComplete)...)
                        }</span>
                }
        }

        // We cannot use finalCmd.Flags() because we may not have called ParsedFlags() for commands
        // that have set DisableFlagParsing; it is ParseFlags() that merges the inherited and
        // non-inherited flags.
        <span class="cov8" title="1">finalCmd.InheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                doCompleteRequiredFlags(flag)
        }</span>)
        <span class="cov8" title="1">finalCmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) </span><span class="cov8" title="1">{
                doCompleteRequiredFlags(flag)
        }</span>)

        <span class="cov8" title="1">return completions</span>
}

func checkIfFlagCompletion(finalCmd *Command, args []string, lastArg string) (*pflag.Flag, []string, string, error) <span class="cov8" title="1">{
        if finalCmd.DisableFlagParsing </span><span class="cov8" title="1">{
                // We only do flag completion if we are allowed to parse flags
                // This is important for commands which have requested to do their own flag completion.
                return nil, args, lastArg, nil
        }</span>

        <span class="cov8" title="1">var flagName string
        trimmedArgs := args
        flagWithEqual := false
        orgLastArg := lastArg

        // When doing completion of a flag name, as soon as an argument starts with
        // a '-' we know it is a flag.  We cannot use isFlagArg() here as that function
        // requires the flag name to be complete
        if len(lastArg) &gt; 0 &amp;&amp; lastArg[0] == '-' </span><span class="cov8" title="1">{
                if index := strings.Index(lastArg, "="); index &gt;= 0 </span><span class="cov8" title="1">{
                        // Flag with an =
                        if strings.HasPrefix(lastArg[:index], "--") </span><span class="cov8" title="1">{
                                // Flag has full name
                                flagName = lastArg[2:index]
                        }</span> else<span class="cov8" title="1"> {
                                // Flag is shorthand
                                // We have to get the last shorthand flag name
                                // e.g. `-asd` =&gt; d to provide the correct completion
                                // https://github.com/spf13/cobra/issues/1257
                                flagName = lastArg[index-1 : index]
                        }</span>
                        <span class="cov8" title="1">lastArg = lastArg[index+1:]
                        flagWithEqual = true</span>
                } else<span class="cov8" title="1"> {
                        // Normal flag completion
                        return nil, args, lastArg, nil
                }</span>
        }

        <span class="cov8" title="1">if len(flagName) == 0 </span><span class="cov8" title="1">{
                if len(args) &gt; 0 </span><span class="cov8" title="1">{
                        prevArg := args[len(args)-1]
                        if isFlagArg(prevArg) </span><span class="cov8" title="1">{
                                // Only consider the case where the flag does not contain an =.
                                // If the flag contains an = it means it has already been fully processed,
                                // so we don't need to deal with it here.
                                if index := strings.Index(prevArg, "="); index &lt; 0 </span><span class="cov8" title="1">{
                                        if strings.HasPrefix(prevArg, "--") </span><span class="cov8" title="1">{
                                                // Flag has full name
                                                flagName = prevArg[2:]
                                        }</span> else<span class="cov8" title="1"> {
                                                // Flag is shorthand
                                                // We have to get the last shorthand flag name
                                                // e.g. `-asd` =&gt; d to provide the correct completion
                                                // https://github.com/spf13/cobra/issues/1257
                                                flagName = prevArg[len(prevArg)-1:]
                                        }</span>
                                        // Remove the uncompleted flag or else there could be an error created
                                        // for an invalid value for that flag
                                        <span class="cov8" title="1">trimmedArgs = args[:len(args)-1]</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if len(flagName) == 0 </span><span class="cov8" title="1">{
                // Not doing flag completion
                return nil, trimmedArgs, lastArg, nil
        }</span>

        <span class="cov8" title="1">flag := findFlag(finalCmd, flagName)
        if flag == nil </span><span class="cov8" title="1">{
                // Flag not supported by this command, the interspersed option might be set so return the original args
                return nil, args, orgLastArg, &amp;flagCompError{subCommand: finalCmd.Name(), flagName: flagName}
        }</span>

        <span class="cov8" title="1">if !flagWithEqual </span><span class="cov8" title="1">{
                if len(flag.NoOptDefVal) != 0 </span><span class="cov8" title="1">{
                        // We had assumed dealing with a two-word flag but the flag is a boolean flag.
                        // In that case, there is no value following it, so we are not really doing flag completion.
                        // Reset everything to do noun completion.
                        trimmedArgs = args
                        flag = nil
                }</span>
        }

        <span class="cov8" title="1">return flag, trimmedArgs, lastArg, nil</span>
}

// InitDefaultCompletionCmd adds a default 'completion' command to c.
// This function will do nothing if any of the following is true:
// 1- the feature has been explicitly disabled by the program,
// 2- c has no subcommands (to avoid creating one),
// 3- c already has a 'completion' command provided by the program.
func (c *Command) InitDefaultCompletionCmd() <span class="cov8" title="1">{
        if c.CompletionOptions.DisableDefaultCmd || !c.HasSubCommands() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for _, cmd := range c.commands </span><span class="cov8" title="1">{
                if cmd.Name() == compCmdName || cmd.HasAlias(compCmdName) </span><span class="cov8" title="1">{
                        // A completion command is already available
                        return
                }</span>
        }

        <span class="cov8" title="1">haveNoDescFlag := !c.CompletionOptions.DisableNoDescFlag &amp;&amp; !c.CompletionOptions.DisableDescriptions

        completionCmd := &amp;Command{
                Use:   compCmdName,
                Short: "Generate the autocompletion script for the specified shell",
                Long: fmt.Sprintf(`Generate the autocompletion script for %[1]s for the specified shell.
See each sub-command's help for details on how to use the generated script.
`, c.Root().Name()),
                Args:              NoArgs,
                ValidArgsFunction: NoFileCompletions,
                Hidden:            c.CompletionOptions.HiddenDefaultCmd,
                GroupID:           c.completionCommandGroupID,
        }
        c.AddCommand(completionCmd)

        out := c.OutOrStdout()
        noDesc := c.CompletionOptions.DisableDescriptions
        shortDesc := "Generate the autocompletion script for %s"
        bash := &amp;Command{
                Use:   "bash",
                Short: fmt.Sprintf(shortDesc, "bash"),
                Long: fmt.Sprintf(`Generate the autocompletion script for the bash shell.

This script depends on the 'bash-completion' package.
If it is not installed already, you can install it via your OS's package manager.

To load completions in your current shell session:

        source &lt;(%[1]s completion bash)

To load completions for every new session, execute once:

#### Linux:

        %[1]s completion bash &gt; /etc/bash_completion.d/%[1]s

#### macOS:

        %[1]s completion bash &gt; $(brew --prefix)/etc/bash_completion.d/%[1]s

You will need to start a new shell for this setup to take effect.
`, c.Root().Name()),
                Args:                  NoArgs,
                DisableFlagsInUseLine: true,
                ValidArgsFunction:     NoFileCompletions,
                RunE: func(cmd *Command, args []string) error </span><span class="cov0" title="0">{
                        return cmd.Root().GenBashCompletionV2(out, !noDesc)
                }</span>,
        }
        <span class="cov8" title="1">if haveNoDescFlag </span><span class="cov8" title="1">{
                bash.Flags().BoolVar(&amp;noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)
        }</span>

        <span class="cov8" title="1">zsh := &amp;Command{
                Use:   "zsh",
                Short: fmt.Sprintf(shortDesc, "zsh"),
                Long: fmt.Sprintf(`Generate the autocompletion script for the zsh shell.

If shell completion is not already enabled in your environment you will need
to enable it.  You can execute the following once:

        echo "autoload -U compinit; compinit" &gt;&gt; ~/.zshrc

To load completions in your current shell session:

        source &lt;(%[1]s completion zsh)

To load completions for every new session, execute once:

#### Linux:

        %[1]s completion zsh &gt; "${fpath[1]}/_%[1]s"

#### macOS:

        %[1]s completion zsh &gt; $(brew --prefix)/share/zsh/site-functions/_%[1]s

You will need to start a new shell for this setup to take effect.
`, c.Root().Name()),
                Args:              NoArgs,
                ValidArgsFunction: NoFileCompletions,
                RunE: func(cmd *Command, args []string) error </span><span class="cov8" title="1">{
                        if noDesc </span><span class="cov8" title="1">{
                                return cmd.Root().GenZshCompletionNoDesc(out)
                        }</span>
                        <span class="cov8" title="1">return cmd.Root().GenZshCompletion(out)</span>
                },
        }
        <span class="cov8" title="1">if haveNoDescFlag </span><span class="cov8" title="1">{
                zsh.Flags().BoolVar(&amp;noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)
        }</span>

        <span class="cov8" title="1">fish := &amp;Command{
                Use:   "fish",
                Short: fmt.Sprintf(shortDesc, "fish"),
                Long: fmt.Sprintf(`Generate the autocompletion script for the fish shell.

To load completions in your current shell session:

        %[1]s completion fish | source

To load completions for every new session, execute once:

        %[1]s completion fish &gt; ~/.config/fish/completions/%[1]s.fish

You will need to start a new shell for this setup to take effect.
`, c.Root().Name()),
                Args:              NoArgs,
                ValidArgsFunction: NoFileCompletions,
                RunE: func(cmd *Command, args []string) error </span><span class="cov0" title="0">{
                        return cmd.Root().GenFishCompletion(out, !noDesc)
                }</span>,
        }
        <span class="cov8" title="1">if haveNoDescFlag </span><span class="cov8" title="1">{
                fish.Flags().BoolVar(&amp;noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)
        }</span>

        <span class="cov8" title="1">powershell := &amp;Command{
                Use:   "powershell",
                Short: fmt.Sprintf(shortDesc, "powershell"),
                Long: fmt.Sprintf(`Generate the autocompletion script for powershell.

To load completions in your current shell session:

        %[1]s completion powershell | Out-String | Invoke-Expression

To load completions for every new session, add the output of the above command
to your powershell profile.
`, c.Root().Name()),
                Args:              NoArgs,
                ValidArgsFunction: NoFileCompletions,
                RunE: func(cmd *Command, args []string) error </span><span class="cov0" title="0">{
                        if noDesc </span><span class="cov0" title="0">{
                                return cmd.Root().GenPowerShellCompletion(out)
                        }</span>
                        <span class="cov0" title="0">return cmd.Root().GenPowerShellCompletionWithDesc(out)</span>

                },
        }
        <span class="cov8" title="1">if haveNoDescFlag </span><span class="cov8" title="1">{
                powershell.Flags().BoolVar(&amp;noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)
        }</span>

        <span class="cov8" title="1">completionCmd.AddCommand(bash, zsh, fish, powershell)</span>
}

func findFlag(cmd *Command, name string) *pflag.Flag <span class="cov8" title="1">{
        flagSet := cmd.Flags()
        if len(name) == 1 </span><span class="cov8" title="1">{
                // First convert the short flag into a long flag
                // as the cmd.Flag() search only accepts long flags
                if short := flagSet.ShorthandLookup(name); short != nil </span><span class="cov8" title="1">{
                        name = short.Name
                }</span> else<span class="cov0" title="0"> {
                        set := cmd.InheritedFlags()
                        if short = set.ShorthandLookup(name); short != nil </span><span class="cov0" title="0">{
                                name = short.Name
                        }</span> else<span class="cov0" title="0"> {
                                return nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return cmd.Flag(name)</span>
}

// CompDebug prints the specified string to the same file as where the
// completion script prints its logs.
// Note that completion printouts should never be on stdout as they would
// be wrongly interpreted as actual completion choices by the completion script.
func CompDebug(msg string, printToStdErr bool) <span class="cov8" title="1">{
        msg = fmt.Sprintf("[Debug] %s", msg)

        // Such logs are only printed when the user has set the environment
        // variable BASH_COMP_DEBUG_FILE to the path of some file to be used.
        if path := os.Getenv("BASH_COMP_DEBUG_FILE"); path != "" </span><span class="cov0" title="0">{
                f, err := os.OpenFile(path,
                        os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
                if err == nil </span><span class="cov0" title="0">{
                        defer f.Close()
                        WriteStringAndCheck(f, msg)
                }</span>
        }

        <span class="cov8" title="1">if printToStdErr </span><span class="cov8" title="1">{
                // Must print to stderr for this not to be read by the completion script.
                fmt.Fprint(os.Stderr, msg)
        }</span>
}

// CompDebugln prints the specified string with a newline at the end
// to the same file as where the completion script prints its logs.
// Such logs are only printed when the user has set the environment
// variable BASH_COMP_DEBUG_FILE to the path of some file to be used.
func CompDebugln(msg string, printToStdErr bool) <span class="cov0" title="0">{
        CompDebug(fmt.Sprintf("%s\n", msg), printToStdErr)
}</span>

// CompError prints the specified completion message to stderr.
func CompError(msg string) <span class="cov8" title="1">{
        msg = fmt.Sprintf("[Error] %s", msg)
        CompDebug(msg, true)
}</span>

// CompErrorln prints the specified completion message to stderr with a newline at the end.
func CompErrorln(msg string) <span class="cov8" title="1">{
        CompError(fmt.Sprintf("%s\n", msg))
}</span>

// These values should not be changed: users will be using them explicitly.
const (
        configEnvVarGlobalPrefix       = "COBRA"
        configEnvVarSuffixDescriptions = "COMPLETION_DESCRIPTIONS"
)

var configEnvVarPrefixSubstRegexp = regexp.MustCompile(`[^A-Z0-9_]`)

// configEnvVar returns the name of the program-specific configuration environment
// variable.  It has the format &lt;PROGRAM&gt;_&lt;SUFFIX&gt; where &lt;PROGRAM&gt; is the name of the
// root command in upper case, with all non-ASCII-alphanumeric characters replaced by `_`.
func configEnvVar(name, suffix string) string <span class="cov8" title="1">{
        // This format should not be changed: users will be using it explicitly.
        v := strings.ToUpper(fmt.Sprintf("%s_%s", name, suffix))
        v = configEnvVarPrefixSubstRegexp.ReplaceAllString(v, "_")
        return v
}</span>

// getEnvConfig returns the value of the configuration environment variable
// &lt;PROGRAM&gt;_&lt;SUFFIX&gt; where &lt;PROGRAM&gt; is the name of the root command in upper
// case, with all non-ASCII-alphanumeric characters replaced by `_`.
// If the value is empty or not set, the value of the environment variable
// COBRA_&lt;SUFFIX&gt; is returned instead.
func getEnvConfig(cmd *Command, suffix string) string <span class="cov8" title="1">{
        v := os.Getenv(configEnvVar(cmd.Root().Name(), suffix))
        if v == "" </span><span class="cov8" title="1">{
                v = os.Getenv(configEnvVar(configEnvVarGlobalPrefix, suffix))
        }</span>
        <span class="cov8" title="1">return v</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

func genFishComp(buf io.StringWriter, name string, includeDesc bool) <span class="cov8" title="1">{
        // Variables should not contain a '-' or ':' character
        nameForVar := name
        nameForVar = strings.ReplaceAll(nameForVar, "-", "_")
        nameForVar = strings.ReplaceAll(nameForVar, ":", "_")

        compCmd := ShellCompRequestCmd
        if !includeDesc </span><span class="cov8" title="1">{
                compCmd = ShellCompNoDescRequestCmd
        }</span>
        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf("# fish completion for %-36s -*- shell-script -*-\n", name))
        WriteStringAndCheck(buf, fmt.Sprintf(`
function __%[1]s_debug
    set -l file "$BASH_COMP_DEBUG_FILE"
    if test -n "$file"
        echo "$argv" &gt;&gt; $file
    end
end

function __%[1]s_perform_completion
    __%[1]s_debug "Starting __%[1]s_perform_completion"

    # Extract all args except the last one
    set -l args (commandline -opc)
    # Extract the last arg and escape it in case it is a space
    set -l lastArg (string escape -- (commandline -ct))

    __%[1]s_debug "args: $args"
    __%[1]s_debug "last arg: $lastArg"

    # Disable ActiveHelp which is not supported for fish shell
    set -l requestComp "%[10]s=0 $args[1] %[3]s $args[2..-1] $lastArg"

    __%[1]s_debug "Calling $requestComp"
    set -l results (eval $requestComp 2&gt; /dev/null)

    # Some programs may output extra empty lines after the directive.
    # Let's ignore them or else it will break completion.
    # Ref: https://github.com/spf13/cobra/issues/1279
    for line in $results[-1..1]
        if test (string trim -- $line) = ""
            # Found an empty line, remove it
            set results $results[1..-2]
        else
            # Found non-empty line, we have our proper output
            break
        end
    end

    set -l comps $results[1..-2]
    set -l directiveLine $results[-1]

    # For Fish, when completing a flag with an = (e.g., &lt;program&gt; -n=&lt;TAB&gt;)
    # completions must be prefixed with the flag
    set -l flagPrefix (string match -r -- '-.*=' "$lastArg")

    __%[1]s_debug "Comps: $comps"
    __%[1]s_debug "DirectiveLine: $directiveLine"
    __%[1]s_debug "flagPrefix: $flagPrefix"

    for comp in $comps
        printf "%%s%%s\n" "$flagPrefix" "$comp"
    end

    printf "%%s\n" "$directiveLine"
end

# this function limits calls to __%[1]s_perform_completion, by caching the result behind $__%[1]s_perform_completion_once_result
function __%[1]s_perform_completion_once
    __%[1]s_debug "Starting __%[1]s_perform_completion_once"

    if test -n "$__%[1]s_perform_completion_once_result"
        __%[1]s_debug "Seems like a valid result already exists, skipping __%[1]s_perform_completion"
        return 0
    end

    set --global __%[1]s_perform_completion_once_result (__%[1]s_perform_completion)
    if test -z "$__%[1]s_perform_completion_once_result"
        __%[1]s_debug "No completions, probably due to a failure"
        return 1
    end

    __%[1]s_debug "Performed completions and set __%[1]s_perform_completion_once_result"
    return 0
end

# this function is used to clear the $__%[1]s_perform_completion_once_result variable after completions are run
function __%[1]s_clear_perform_completion_once_result
    __%[1]s_debug ""
    __%[1]s_debug "========= clearing previously set __%[1]s_perform_completion_once_result variable =========="
    set --erase __%[1]s_perform_completion_once_result
    __%[1]s_debug "Successfully erased the variable __%[1]s_perform_completion_once_result"
end

function __%[1]s_requires_order_preservation
    __%[1]s_debug ""
    __%[1]s_debug "========= checking if order preservation is required =========="

    __%[1]s_perform_completion_once
    if test -z "$__%[1]s_perform_completion_once_result"
        __%[1]s_debug "Error determining if order preservation is required"
        return 1
    end

    set -l directive (string sub --start 2 $__%[1]s_perform_completion_once_result[-1])
    __%[1]s_debug "Directive is: $directive"

    set -l shellCompDirectiveKeepOrder %[9]d
    set -l keeporder (math (math --scale 0 $directive / $shellCompDirectiveKeepOrder) %% 2)
    __%[1]s_debug "Keeporder is: $keeporder"

    if test $keeporder -ne 0
        __%[1]s_debug "This does require order preservation"
        return 0
    end

    __%[1]s_debug "This doesn't require order preservation"
    return 1
end


# This function does two things:
# - Obtain the completions and store them in the global __%[1]s_comp_results
# - Return false if file completion should be performed
function __%[1]s_prepare_completions
    __%[1]s_debug ""
    __%[1]s_debug "========= starting completion logic =========="

    # Start fresh
    set --erase __%[1]s_comp_results

    __%[1]s_perform_completion_once
    __%[1]s_debug "Completion results: $__%[1]s_perform_completion_once_result"

    if test -z "$__%[1]s_perform_completion_once_result"
        __%[1]s_debug "No completion, probably due to a failure"
        # Might as well do file completion, in case it helps
        return 1
    end

    set -l directive (string sub --start 2 $__%[1]s_perform_completion_once_result[-1])
    set --global __%[1]s_comp_results $__%[1]s_perform_completion_once_result[1..-2]

    __%[1]s_debug "Completions are: $__%[1]s_comp_results"
    __%[1]s_debug "Directive is: $directive"

    set -l shellCompDirectiveError %[4]d
    set -l shellCompDirectiveNoSpace %[5]d
    set -l shellCompDirectiveNoFileComp %[6]d
    set -l shellCompDirectiveFilterFileExt %[7]d
    set -l shellCompDirectiveFilterDirs %[8]d

    if test -z "$directive"
        set directive 0
    end

    set -l compErr (math (math --scale 0 $directive / $shellCompDirectiveError) %% 2)
    if test $compErr -eq 1
        __%[1]s_debug "Received error directive: aborting."
        # Might as well do file completion, in case it helps
        return 1
    end

    set -l filefilter (math (math --scale 0 $directive / $shellCompDirectiveFilterFileExt) %% 2)
    set -l dirfilter (math (math --scale 0 $directive / $shellCompDirectiveFilterDirs) %% 2)
    if test $filefilter -eq 1; or test $dirfilter -eq 1
        __%[1]s_debug "File extension filtering or directory filtering not supported"
        # Do full file completion instead
        return 1
    end

    set -l nospace (math (math --scale 0 $directive / $shellCompDirectiveNoSpace) %% 2)
    set -l nofiles (math (math --scale 0 $directive / $shellCompDirectiveNoFileComp) %% 2)

    __%[1]s_debug "nospace: $nospace, nofiles: $nofiles"

    # If we want to prevent a space, or if file completion is NOT disabled,
    # we need to count the number of valid completions.
    # To do so, we will filter on prefix as the completions we have received
    # may not already be filtered so as to allow fish to match on different
    # criteria than the prefix.
    if test $nospace -ne 0; or test $nofiles -eq 0
        set -l prefix (commandline -t | string escape --style=regex)
        __%[1]s_debug "prefix: $prefix"

        set -l completions (string match -r -- "^$prefix.*" $__%[1]s_comp_results)
        set --global __%[1]s_comp_results $completions
        __%[1]s_debug "Filtered completions are: $__%[1]s_comp_results"

        # Important not to quote the variable for count to work
        set -l numComps (count $__%[1]s_comp_results)
        __%[1]s_debug "numComps: $numComps"

        if test $numComps -eq 1; and test $nospace -ne 0
            # We must first split on \t to get rid of the descriptions to be
            # able to check what the actual completion will be.
            # We don't need descriptions anyway since there is only a single
            # real completion which the shell will expand immediately.
            set -l split (string split --max 1 \t $__%[1]s_comp_results[1])

            # Fish won't add a space if the completion ends with any
            # of the following characters: @=/:.,
            set -l lastChar (string sub -s -1 -- $split)
            if not string match -r -q "[@=/:.,]" -- "$lastChar"
                # In other cases, to support the "nospace" directive we trick the shell
                # by outputting an extra, longer completion.
                __%[1]s_debug "Adding second completion to perform nospace directive"
                set --global __%[1]s_comp_results $split[1] $split[1].
                __%[1]s_debug "Completions are now: $__%[1]s_comp_results"
            end
        end

        if test $numComps -eq 0; and test $nofiles -eq 0
            # To be consistent with bash and zsh, we only trigger file
            # completion when there are no other completions
            __%[1]s_debug "Requesting file completion"
            return 1
        end
    end

    return 0
end

# Since Fish completions are only loaded once the user triggers them, we trigger them ourselves
# so we can properly delete any completions provided by another script.
# Only do this if the program can be found, or else fish may print some errors; besides,
# the existing completions will only be loaded if the program can be found.
if type -q "%[2]s"
    # The space after the program name is essential to trigger completion for the program
    # and not completion of the program name itself.
    # Also, we use '&gt; /dev/null 2&gt;&amp;1' since '&amp;&gt;' is not supported in older versions of fish.
    complete --do-complete "%[2]s " &gt; /dev/null 2&gt;&amp;1
end

# Remove any pre-existing completions for the program since we will be handling all of them.
complete -c %[2]s -e

# this will get called after the two calls below and clear the $__%[1]s_perform_completion_once_result global
complete -c %[2]s -n '__%[1]s_clear_perform_completion_once_result'
# The call to __%[1]s_prepare_completions will setup __%[1]s_comp_results
# which provides the program's completion choices.
# If this doesn't require order preservation, we don't use the -k flag
complete -c %[2]s -n 'not __%[1]s_requires_order_preservation &amp;&amp; __%[1]s_prepare_completions' -f -a '$__%[1]s_comp_results'
# otherwise we use the -k flag
complete -k -c %[2]s -n '__%[1]s_requires_order_preservation &amp;&amp; __%[1]s_prepare_completions' -f -a '$__%[1]s_comp_results'
`, nameForVar, name, compCmd,
                ShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,
                ShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder, activeHelpEnvVar(name)))</span>
}

// GenFishCompletion generates fish completion file and writes to the passed writer.
func (c *Command) GenFishCompletion(w io.Writer, includeDesc bool) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        genFishComp(buf, c.Name(), includeDesc)
        _, err := buf.WriteTo(w)
        return err
}</span>

// GenFishCompletionFile generates fish completion file.
func (c *Command) GenFishCompletionFile(filename string, includeDesc bool) error <span class="cov8" title="1">{
        outFile, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer outFile.Close()

        return c.GenFishCompletion(outFile, includeDesc)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "fmt"
        "sort"
        "strings"

        flag "github.com/spf13/pflag"
)

const (
        requiredAsGroupAnnotation   = "cobra_annotation_required_if_others_set"
        oneRequiredAnnotation       = "cobra_annotation_one_required"
        mutuallyExclusiveAnnotation = "cobra_annotation_mutually_exclusive"
)

// MarkFlagsRequiredTogether marks the given flags with annotations so that Cobra errors
// if the command is invoked with a subset (but not all) of the given flags.
func (c *Command) MarkFlagsRequiredTogether(flagNames ...string) <span class="cov8" title="1">{
        c.mergePersistentFlags()
        for _, v := range flagNames </span><span class="cov8" title="1">{
                f := c.Flags().Lookup(v)
                if f == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to find flag %q and mark it as being required in a flag group", v))</span>
                }
                <span class="cov8" title="1">if err := c.Flags().SetAnnotation(v, requiredAsGroupAnnotation, append(f.Annotations[requiredAsGroupAnnotation], strings.Join(flagNames, " "))); err != nil </span><span class="cov0" title="0">{
                        // Only errs if the flag isn't found.
                        panic(err)</span>
                }
        }
}

// MarkFlagsOneRequired marks the given flags with annotations so that Cobra errors
// if the command is invoked without at least one flag from the given set of flags.
func (c *Command) MarkFlagsOneRequired(flagNames ...string) <span class="cov8" title="1">{
        c.mergePersistentFlags()
        for _, v := range flagNames </span><span class="cov8" title="1">{
                f := c.Flags().Lookup(v)
                if f == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to find flag %q and mark it as being in a one-required flag group", v))</span>
                }
                <span class="cov8" title="1">if err := c.Flags().SetAnnotation(v, oneRequiredAnnotation, append(f.Annotations[oneRequiredAnnotation], strings.Join(flagNames, " "))); err != nil </span><span class="cov0" title="0">{
                        // Only errs if the flag isn't found.
                        panic(err)</span>
                }
        }
}

// MarkFlagsMutuallyExclusive marks the given flags with annotations so that Cobra errors
// if the command is invoked with more than one flag from the given set of flags.
func (c *Command) MarkFlagsMutuallyExclusive(flagNames ...string) <span class="cov8" title="1">{
        c.mergePersistentFlags()
        for _, v := range flagNames </span><span class="cov8" title="1">{
                f := c.Flags().Lookup(v)
                if f == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to find flag %q and mark it as being in a mutually exclusive flag group", v))</span>
                }
                // Each time this is called is a single new entry; this allows it to be a member of multiple groups if needed.
                <span class="cov8" title="1">if err := c.Flags().SetAnnotation(v, mutuallyExclusiveAnnotation, append(f.Annotations[mutuallyExclusiveAnnotation], strings.Join(flagNames, " "))); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
}

// ValidateFlagGroups validates the mutuallyExclusive/oneRequired/requiredAsGroup logic and returns the
// first error encountered.
func (c *Command) ValidateFlagGroups() error <span class="cov8" title="1">{
        if c.DisableFlagParsing </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">flags := c.Flags()

        // groupStatus format is the list of flags as a unique ID,
        // then a map of each flag name and whether it is set or not.
        groupStatus := map[string]map[string]bool{}
        oneRequiredGroupStatus := map[string]map[string]bool{}
        mutuallyExclusiveGroupStatus := map[string]map[string]bool{}
        flags.VisitAll(func(pflag *flag.Flag) </span><span class="cov8" title="1">{
                processFlagForGroupAnnotation(flags, pflag, requiredAsGroupAnnotation, groupStatus)
                processFlagForGroupAnnotation(flags, pflag, oneRequiredAnnotation, oneRequiredGroupStatus)
                processFlagForGroupAnnotation(flags, pflag, mutuallyExclusiveAnnotation, mutuallyExclusiveGroupStatus)
        }</span>)

        <span class="cov8" title="1">if err := validateRequiredFlagGroups(groupStatus); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateOneRequiredFlagGroups(oneRequiredGroupStatus); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := validateExclusiveFlagGroups(mutuallyExclusiveGroupStatus); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func hasAllFlags(fs *flag.FlagSet, flagnames ...string) bool <span class="cov8" title="1">{
        for _, fname := range flagnames </span><span class="cov8" title="1">{
                f := fs.Lookup(fname)
                if f == nil </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func processFlagForGroupAnnotation(flags *flag.FlagSet, pflag *flag.Flag, annotation string, groupStatus map[string]map[string]bool) <span class="cov8" title="1">{
        groupInfo, found := pflag.Annotations[annotation]
        if found </span><span class="cov8" title="1">{
                for _, group := range groupInfo </span><span class="cov8" title="1">{
                        if groupStatus[group] == nil </span><span class="cov8" title="1">{
                                flagnames := strings.Split(group, " ")

                                // Only consider this flag group at all if all the flags are defined.
                                if !hasAllFlags(flags, flagnames...) </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">groupStatus[group] = make(map[string]bool, len(flagnames))
                                for _, name := range flagnames </span><span class="cov8" title="1">{
                                        groupStatus[group][name] = false
                                }</span>
                        }

                        <span class="cov8" title="1">groupStatus[group][pflag.Name] = pflag.Changed</span>
                }
        }
}

func validateRequiredFlagGroups(data map[string]map[string]bool) error <span class="cov8" title="1">{
        keys := sortedKeys(data)
        for _, flagList := range keys </span><span class="cov8" title="1">{
                flagnameAndStatus := data[flagList]

                unset := []string{}
                for flagname, isSet := range flagnameAndStatus </span><span class="cov8" title="1">{
                        if !isSet </span><span class="cov8" title="1">{
                                unset = append(unset, flagname)
                        }</span>
                }
                <span class="cov8" title="1">if len(unset) == len(flagnameAndStatus) || len(unset) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Sort values, so they can be tested/scripted against consistently.
                <span class="cov8" title="1">sort.Strings(unset)
                return fmt.Errorf("if any flags in the group [%v] are set they must all be set; missing %v", flagList, unset)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func validateOneRequiredFlagGroups(data map[string]map[string]bool) error <span class="cov8" title="1">{
        keys := sortedKeys(data)
        for _, flagList := range keys </span><span class="cov8" title="1">{
                flagnameAndStatus := data[flagList]
                var set []string
                for flagname, isSet := range flagnameAndStatus </span><span class="cov8" title="1">{
                        if isSet </span><span class="cov8" title="1">{
                                set = append(set, flagname)
                        }</span>
                }
                <span class="cov8" title="1">if len(set) &gt;= 1 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Sort values, so they can be tested/scripted against consistently.
                <span class="cov8" title="1">sort.Strings(set)
                return fmt.Errorf("at least one of the flags in the group [%v] is required", flagList)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateExclusiveFlagGroups(data map[string]map[string]bool) error <span class="cov8" title="1">{
        keys := sortedKeys(data)
        for _, flagList := range keys </span><span class="cov8" title="1">{
                flagnameAndStatus := data[flagList]
                var set []string
                for flagname, isSet := range flagnameAndStatus </span><span class="cov8" title="1">{
                        if isSet </span><span class="cov8" title="1">{
                                set = append(set, flagname)
                        }</span>
                }
                <span class="cov8" title="1">if len(set) == 0 || len(set) == 1 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Sort values, so they can be tested/scripted against consistently.
                <span class="cov8" title="1">sort.Strings(set)
                return fmt.Errorf("if any flags in the group [%v] are set none of the others can be; %v were all set", flagList, set)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func sortedKeys(m map[string]map[string]bool) []string <span class="cov8" title="1">{
        keys := make([]string, len(m))
        i := 0
        for k := range m </span><span class="cov8" title="1">{
                keys[i] = k
                i++
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        return keys</span>
}

// enforceFlagGroupsForCompletion will do the following:
// - when a flag in a group is present, other flags in the group will be marked required
// - when none of the flags in a one-required group are present, all flags in the group will be marked required
// - when a flag in a mutually exclusive group is present, other flags in the group will be marked as hidden
// This allows the standard completion logic to behave appropriately for flag groups
func (c *Command) enforceFlagGroupsForCompletion() <span class="cov8" title="1">{
        if c.DisableFlagParsing </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">flags := c.Flags()
        groupStatus := map[string]map[string]bool{}
        oneRequiredGroupStatus := map[string]map[string]bool{}
        mutuallyExclusiveGroupStatus := map[string]map[string]bool{}
        c.Flags().VisitAll(func(pflag *flag.Flag) </span><span class="cov8" title="1">{
                processFlagForGroupAnnotation(flags, pflag, requiredAsGroupAnnotation, groupStatus)
                processFlagForGroupAnnotation(flags, pflag, oneRequiredAnnotation, oneRequiredGroupStatus)
                processFlagForGroupAnnotation(flags, pflag, mutuallyExclusiveAnnotation, mutuallyExclusiveGroupStatus)
        }</span>)

        // If a flag that is part of a group is present, we make all the other flags
        // of that group required so that the shell completion suggests them automatically
        <span class="cov8" title="1">for flagList, flagnameAndStatus := range groupStatus </span><span class="cov8" title="1">{
                for _, isSet := range flagnameAndStatus </span><span class="cov8" title="1">{
                        if isSet </span><span class="cov8" title="1">{
                                // One of the flags of the group is set, mark the other ones as required
                                for _, fName := range strings.Split(flagList, " ") </span><span class="cov8" title="1">{
                                        _ = c.MarkFlagRequired(fName)
                                }</span>
                        }
                }
        }

        // If none of the flags of a one-required group are present, we make all the flags
        // of that group required so that the shell completion suggests them automatically
        <span class="cov8" title="1">for flagList, flagnameAndStatus := range oneRequiredGroupStatus </span><span class="cov8" title="1">{
                isSet := false

                for _, isSet = range flagnameAndStatus </span><span class="cov8" title="1">{
                        if isSet </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                // None of the flags of the group are set, mark all flags in the group
                // as required
                <span class="cov8" title="1">if !isSet </span><span class="cov8" title="1">{
                        for _, fName := range strings.Split(flagList, " ") </span><span class="cov8" title="1">{
                                _ = c.MarkFlagRequired(fName)
                        }</span>
                }
        }

        // If a flag that is mutually exclusive to others is present, we hide the other
        // flags of that group so the shell completion does not suggest them
        <span class="cov8" title="1">for flagList, flagnameAndStatus := range mutuallyExclusiveGroupStatus </span><span class="cov8" title="1">{
                for flagName, isSet := range flagnameAndStatus </span><span class="cov8" title="1">{
                        if isSet </span><span class="cov8" title="1">{
                                // One of the flags of the mutually exclusive group is set, mark the other ones as hidden
                                // Don't mark the flag that is already set as hidden because it may be an
                                // array or slice flag and therefore must continue being suggested
                                for _, fName := range strings.Split(flagList, " ") </span><span class="cov8" title="1">{
                                        if fName != flagName </span><span class="cov8" title="1">{
                                                flag := c.Flags().Lookup(fName)
                                                flag.Hidden = true
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// The generated scripts require PowerShell v5.0+ (which comes Windows 10, but
// can be downloaded separately for windows 7 or 8.1).

package cobra

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

func genPowerShellComp(buf io.StringWriter, name string, includeDesc bool) <span class="cov8" title="1">{
        // Variables should not contain a '-' or ':' character
        nameForVar := name
        nameForVar = strings.ReplaceAll(nameForVar, "-", "_")
        nameForVar = strings.ReplaceAll(nameForVar, ":", "_")

        compCmd := ShellCompRequestCmd
        if !includeDesc </span><span class="cov8" title="1">{
                compCmd = ShellCompNoDescRequestCmd
        }</span>
        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf(`# powershell completion for %-36[1]s -*- shell-script -*-

function __%[1]s_debug {
    if ($env:BASH_COMP_DEBUG_FILE) {
        "$args" | Out-File -Append -FilePath "$env:BASH_COMP_DEBUG_FILE"
    }
}

filter __%[1]s_escapeStringWithSpecialChars {
`+"    $_ -replace '\\s|#|@|\\$|;|,|''|\\{|\\}|\\(|\\)|\"|`|\\||&lt;|&gt;|&amp;','`$&amp;'"+`
}

[scriptblock]${__%[2]sCompleterBlock} = {
    param(
            $WordToComplete,
            $CommandAst,
            $CursorPosition
        )

    # Get the current command line and convert into a string
    $Command = $CommandAst.CommandElements
    $Command = "$Command"

    __%[1]s_debug ""
    __%[1]s_debug "========= starting completion logic =========="
    __%[1]s_debug "WordToComplete: $WordToComplete Command: $Command CursorPosition: $CursorPosition"

    # The user could have moved the cursor backwards on the command-line.
    # We need to trigger completion from the $CursorPosition location, so we need
    # to truncate the command-line ($Command) up to the $CursorPosition location.
    # Make sure the $Command is longer then the $CursorPosition before we truncate.
    # This happens because the $Command does not include the last space.
    if ($Command.Length -gt $CursorPosition) {
        $Command=$Command.Substring(0,$CursorPosition)
    }
    __%[1]s_debug "Truncated command: $Command"

    $ShellCompDirectiveError=%[4]d
    $ShellCompDirectiveNoSpace=%[5]d
    $ShellCompDirectiveNoFileComp=%[6]d
    $ShellCompDirectiveFilterFileExt=%[7]d
    $ShellCompDirectiveFilterDirs=%[8]d
    $ShellCompDirectiveKeepOrder=%[9]d

    # Prepare the command to request completions for the program.
    # Split the command at the first space to separate the program and arguments.
    $Program,$Arguments = $Command.Split(" ",2)

    $RequestComp="$Program %[3]s $Arguments"
    __%[1]s_debug "RequestComp: $RequestComp"

    # we cannot use $WordToComplete because it
    # has the wrong values if the cursor was moved
    # so use the last argument
    if ($WordToComplete -ne "" ) {
        $WordToComplete = $Arguments.Split(" ")[-1]
    }
    __%[1]s_debug "New WordToComplete: $WordToComplete"


    # Check for flag with equal sign
    $IsEqualFlag = ($WordToComplete -Like "--*=*" )
    if ( $IsEqualFlag ) {
        __%[1]s_debug "Completing equal sign flag"
        # Remove the flag part
        $Flag,$WordToComplete = $WordToComplete.Split("=",2)
    }

    if ( $WordToComplete -eq "" -And ( -Not $IsEqualFlag )) {
        # If the last parameter is complete (there is a space following it)
        # We add an extra empty parameter so we can indicate this to the go method.
        __%[1]s_debug "Adding extra empty parameter"
        # PowerShell 7.2+ changed the way how the arguments are passed to executables,
        # so for pre-7.2 or when Legacy argument passing is enabled we need to use
`+"        # `\"`\" to pass an empty argument, a \"\" or '' does not work!!!"+`
        if ($PSVersionTable.PsVersion -lt [version]'7.2.0' -or
            ($PSVersionTable.PsVersion -lt [version]'7.3.0' -and -not [ExperimentalFeature]::IsEnabled("PSNativeCommandArgumentPassing")) -or
            (($PSVersionTable.PsVersion -ge [version]'7.3.0' -or [ExperimentalFeature]::IsEnabled("PSNativeCommandArgumentPassing")) -and
              $PSNativeCommandArgumentPassing -eq 'Legacy')) {
`+"             $RequestComp=\"$RequestComp\" + ' `\"`\"'"+`
        } else {
             $RequestComp="$RequestComp" + ' ""'
        }
    }

    __%[1]s_debug "Calling $RequestComp"
    # First disable ActiveHelp which is not supported for Powershell
    ${env:%[10]s}=0

    #call the command store the output in $out and redirect stderr and stdout to null
    # $Out is an array contains each line per element
    Invoke-Expression -OutVariable out "$RequestComp" 2&gt;&amp;1 | Out-Null

    # get directive from last line
    [int]$Directive = $Out[-1].TrimStart(':')
    if ($Directive -eq "") {
        # There is no directive specified
        $Directive = 0
    }
    __%[1]s_debug "The completion directive is: $Directive"

    # remove directive (last element) from out
    $Out = $Out | Where-Object { $_ -ne $Out[-1] }
    __%[1]s_debug "The completions are: $Out"

    if (($Directive -band $ShellCompDirectiveError) -ne 0 ) {
        # Error code.  No completion.
        __%[1]s_debug "Received error from custom completion go code"
        return
    }

    $Longest = 0
    [Array]$Values = $Out | ForEach-Object {
        #Split the output in name and description
`+"        $Name, $Description = $_.Split(\"`t\",2)"+`
        __%[1]s_debug "Name: $Name Description: $Description"

        # Look for the longest completion so that we can format things nicely
        if ($Longest -lt $Name.Length) {
            $Longest = $Name.Length
        }

        # Set the description to a one space string if there is none set.
        # This is needed because the CompletionResult does not accept an empty string as argument
        if (-Not $Description) {
            $Description = " "
        }
        @{Name="$Name";Description="$Description"}
    }


    $Space = " "
    if (($Directive -band $ShellCompDirectiveNoSpace) -ne 0 ) {
        # remove the space here
        __%[1]s_debug "ShellCompDirectiveNoSpace is called"
        $Space = ""
    }

    if ((($Directive -band $ShellCompDirectiveFilterFileExt) -ne 0 ) -or
       (($Directive -band $ShellCompDirectiveFilterDirs) -ne 0 ))  {
        __%[1]s_debug "ShellCompDirectiveFilterFileExt ShellCompDirectiveFilterDirs are not supported"

        # return here to prevent the completion of the extensions
        return
    }

    $Values = $Values | Where-Object {
        # filter the result
        $_.Name -like "$WordToComplete*"

        # Join the flag back if we have an equal sign flag
        if ( $IsEqualFlag ) {
            __%[1]s_debug "Join the equal sign flag back to the completion value"
            $_.Name = $Flag + "=" + $_.Name
        }
    }

    # we sort the values in ascending order by name if keep order isn't passed
    if (($Directive -band $ShellCompDirectiveKeepOrder) -eq 0 ) {
        $Values = $Values | Sort-Object -Property Name
    }

    if (($Directive -band $ShellCompDirectiveNoFileComp) -ne 0 ) {
        __%[1]s_debug "ShellCompDirectiveNoFileComp is called"

        if ($Values.Length -eq 0) {
            # Just print an empty string here so the
            # shell does not start to complete paths.
            # We cannot use CompletionResult here because
            # it does not accept an empty string as argument.
            ""
            return
        }
    }

    # Get the current mode
    $Mode = (Get-PSReadLineKeyHandler | Where-Object {$_.Key -eq "Tab" }).Function
    __%[1]s_debug "Mode: $Mode"

    $Values | ForEach-Object {

        # store temporary because switch will overwrite $_
        $comp = $_

        # PowerShell supports three different completion modes
        # - TabCompleteNext (default windows style - on each key press the next option is displayed)
        # - Complete (works like bash)
        # - MenuComplete (works like zsh)
        # You set the mode with Set-PSReadLineKeyHandler -Key Tab -Function &lt;mode&gt;

        # CompletionResult Arguments:
        # 1) CompletionText text to be used as the auto completion result
        # 2) ListItemText   text to be displayed in the suggestion list
        # 3) ResultType     type of completion result
        # 4) ToolTip        text for the tooltip with details about the object

        switch ($Mode) {

            # bash like
            "Complete" {

                if ($Values.Length -eq 1) {
                    __%[1]s_debug "Only one completion left"

                    # insert space after value
                    [System.Management.Automation.CompletionResult]::new($($comp.Name | __%[1]s_escapeStringWithSpecialChars) + $Space, "$($comp.Name)", 'ParameterValue', "$($comp.Description)")

                } else {
                    # Add the proper number of spaces to align the descriptions
                    while($comp.Name.Length -lt $Longest) {
                        $comp.Name = $comp.Name + " "
                    }

                    # Check for empty description and only add parentheses if needed
                    if ($($comp.Description) -eq " " ) {
                        $Description = ""
                    } else {
                        $Description = "  ($($comp.Description))"
                    }

                    [System.Management.Automation.CompletionResult]::new("$($comp.Name)$Description", "$($comp.Name)$Description", 'ParameterValue', "$($comp.Description)")
                }
             }

            # zsh like
            "MenuComplete" {
                # insert space after value
                # MenuComplete will automatically show the ToolTip of
                # the highlighted value at the bottom of the suggestions.
                [System.Management.Automation.CompletionResult]::new($($comp.Name | __%[1]s_escapeStringWithSpecialChars) + $Space, "$($comp.Name)", 'ParameterValue', "$($comp.Description)")
            }

            # TabCompleteNext and in case we get something unknown
            Default {
                # Like MenuComplete but we don't want to add a space here because
                # the user need to press space anyway to get the completion.
                # Description will not be shown because that's not possible with TabCompleteNext
                [System.Management.Automation.CompletionResult]::new($($comp.Name | __%[1]s_escapeStringWithSpecialChars), "$($comp.Name)", 'ParameterValue', "$($comp.Description)")
            }
        }

    }
}

Register-ArgumentCompleter -CommandName '%[1]s' -ScriptBlock ${__%[2]sCompleterBlock}
`, name, nameForVar, compCmd,
                ShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,
                ShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder, activeHelpEnvVar(name)))</span>
}

func (c *Command) genPowerShellCompletion(w io.Writer, includeDesc bool) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        genPowerShellComp(buf, c.Name(), includeDesc)
        _, err := buf.WriteTo(w)
        return err
}</span>

func (c *Command) genPowerShellCompletionFile(filename string, includeDesc bool) error <span class="cov0" title="0">{
        outFile, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        return c.genPowerShellCompletion(outFile, includeDesc)</span>
}

// GenPowerShellCompletionFile generates powershell completion file without descriptions.
func (c *Command) GenPowerShellCompletionFile(filename string) error <span class="cov0" title="0">{
        return c.genPowerShellCompletionFile(filename, false)
}</span>

// GenPowerShellCompletion generates powershell completion file without descriptions
// and writes it to the passed writer.
func (c *Command) GenPowerShellCompletion(w io.Writer) error <span class="cov8" title="1">{
        return c.genPowerShellCompletion(w, false)
}</span>

// GenPowerShellCompletionFileWithDesc generates powershell completion file with descriptions.
func (c *Command) GenPowerShellCompletionFileWithDesc(filename string) error <span class="cov0" title="0">{
        return c.genPowerShellCompletionFile(filename, true)
}</span>

// GenPowerShellCompletionWithDesc generates powershell completion file with descriptions
// and writes it to the passed writer.
func (c *Command) GenPowerShellCompletionWithDesc(w io.Writer) error <span class="cov0" title="0">{
        return c.genPowerShellCompletion(w, true)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "github.com/spf13/pflag"
)

// MarkFlagRequired instructs the various shell completion implementations to
// prioritize the named flag when performing completion,
// and causes your command to report an error if invoked without the flag.
func (c *Command) MarkFlagRequired(name string) error <span class="cov8" title="1">{
        return MarkFlagRequired(c.Flags(), name)
}</span>

// MarkPersistentFlagRequired instructs the various shell completion implementations to
// prioritize the named persistent flag when performing completion,
// and causes your command to report an error if invoked without the flag.
func (c *Command) MarkPersistentFlagRequired(name string) error <span class="cov8" title="1">{
        return MarkFlagRequired(c.PersistentFlags(), name)
}</span>

// MarkFlagRequired instructs the various shell completion implementations to
// prioritize the named flag when performing completion,
// and causes your command to report an error if invoked without the flag.
func MarkFlagRequired(flags *pflag.FlagSet, name string) error <span class="cov8" title="1">{
        return flags.SetAnnotation(name, BashCompOneRequiredFlag, []string{"true"})
}</span>

// MarkFlagFilename instructs the various shell completion implementations to
// limit completions for the named flag to the specified file extensions.
func (c *Command) MarkFlagFilename(name string, extensions ...string) error <span class="cov8" title="1">{
        return MarkFlagFilename(c.Flags(), name, extensions...)
}</span>

// MarkFlagCustom adds the BashCompCustom annotation to the named flag, if it exists.
// The bash completion script will call the bash function f for the flag.
//
// This will only work for bash completion.
// It is recommended to instead use c.RegisterFlagCompletionFunc(...) which allows
// to register a Go function which will work across all shells.
func (c *Command) MarkFlagCustom(name string, f string) error <span class="cov8" title="1">{
        return MarkFlagCustom(c.Flags(), name, f)
}</span>

// MarkPersistentFlagFilename instructs the various shell completion
// implementations to limit completions for the named persistent flag to the
// specified file extensions.
func (c *Command) MarkPersistentFlagFilename(name string, extensions ...string) error <span class="cov8" title="1">{
        return MarkFlagFilename(c.PersistentFlags(), name, extensions...)
}</span>

// MarkFlagFilename instructs the various shell completion implementations to
// limit completions for the named flag to the specified file extensions.
func MarkFlagFilename(flags *pflag.FlagSet, name string, extensions ...string) error <span class="cov8" title="1">{
        return flags.SetAnnotation(name, BashCompFilenameExt, extensions)
}</span>

// MarkFlagCustom adds the BashCompCustom annotation to the named flag, if it exists.
// The bash completion script will call the bash function f for the flag.
//
// This will only work for bash completion.
// It is recommended to instead use c.RegisterFlagCompletionFunc(...) which allows
// to register a Go function which will work across all shells.
func MarkFlagCustom(flags *pflag.FlagSet, name string, f string) error <span class="cov8" title="1">{
        return flags.SetAnnotation(name, BashCompCustom, []string{f})
}</span>

// MarkFlagDirname instructs the various shell completion implementations to
// limit completions for the named flag to directory names.
func (c *Command) MarkFlagDirname(name string) error <span class="cov8" title="1">{
        return MarkFlagDirname(c.Flags(), name)
}</span>

// MarkPersistentFlagDirname instructs the various shell completion
// implementations to limit completions for the named persistent flag to
// directory names.
func (c *Command) MarkPersistentFlagDirname(name string) error <span class="cov0" title="0">{
        return MarkFlagDirname(c.PersistentFlags(), name)
}</span>

// MarkFlagDirname instructs the various shell completion implementations to
// limit completions for the named flag to directory names.
func MarkFlagDirname(flags *pflag.FlagSet, name string) error <span class="cov8" title="1">{
        return flags.SetAnnotation(name, BashCompSubdirsInDir, []string{})
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2013-2023 The Cobra Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cobra

import (
        "bytes"
        "fmt"
        "io"
        "os"
)

// GenZshCompletionFile generates zsh completion file including descriptions.
func (c *Command) GenZshCompletionFile(filename string) error <span class="cov0" title="0">{
        return c.genZshCompletionFile(filename, true)
}</span>

// GenZshCompletion generates zsh completion file including descriptions
// and writes it to the passed writer.
func (c *Command) GenZshCompletion(w io.Writer) error <span class="cov8" title="1">{
        return c.genZshCompletion(w, true)
}</span>

// GenZshCompletionFileNoDesc generates zsh completion file without descriptions.
func (c *Command) GenZshCompletionFileNoDesc(filename string) error <span class="cov0" title="0">{
        return c.genZshCompletionFile(filename, false)
}</span>

// GenZshCompletionNoDesc generates zsh completion file without descriptions
// and writes it to the passed writer.
func (c *Command) GenZshCompletionNoDesc(w io.Writer) error <span class="cov8" title="1">{
        return c.genZshCompletion(w, false)
}</span>

// MarkZshCompPositionalArgumentFile only worked for zsh and its behavior was
// not consistent with Bash completion. It has therefore been disabled.
// Instead, when no other completion is specified, file completion is done by
// default for every argument. One can disable file completion on a per-argument
// basis by using ValidArgsFunction and ShellCompDirectiveNoFileComp.
// To achieve file extension filtering, one can use ValidArgsFunction and
// ShellCompDirectiveFilterFileExt.
//
// Deprecated
func (c *Command) MarkZshCompPositionalArgumentFile(argPosition int, patterns ...string) error <span class="cov0" title="0">{
        return nil
}</span>

// MarkZshCompPositionalArgumentWords only worked for zsh. It has therefore
// been disabled.
// To achieve the same behavior across all shells, one can use
// ValidArgs (for the first argument only) or ValidArgsFunction for
// any argument (can include the first one also).
//
// Deprecated
func (c *Command) MarkZshCompPositionalArgumentWords(argPosition int, words ...string) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *Command) genZshCompletionFile(filename string, includeDesc bool) error <span class="cov0" title="0">{
        outFile, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        return c.genZshCompletion(outFile, includeDesc)</span>
}

func (c *Command) genZshCompletion(w io.Writer, includeDesc bool) error <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        genZshComp(buf, c.Name(), includeDesc)
        _, err := buf.WriteTo(w)
        return err
}</span>

func genZshComp(buf io.StringWriter, name string, includeDesc bool) <span class="cov8" title="1">{
        compCmd := ShellCompRequestCmd
        if !includeDesc </span><span class="cov8" title="1">{
                compCmd = ShellCompNoDescRequestCmd
        }</span>
        <span class="cov8" title="1">WriteStringAndCheck(buf, fmt.Sprintf(`#compdef %[1]s
compdef _%[1]s %[1]s

# zsh completion for %-36[1]s -*- shell-script -*-

__%[1]s_debug()
{
    local file="$BASH_COMP_DEBUG_FILE"
    if [[ -n ${file} ]]; then
        echo "$*" &gt;&gt; "${file}"
    fi
}

_%[1]s()
{
    local shellCompDirectiveError=%[3]d
    local shellCompDirectiveNoSpace=%[4]d
    local shellCompDirectiveNoFileComp=%[5]d
    local shellCompDirectiveFilterFileExt=%[6]d
    local shellCompDirectiveFilterDirs=%[7]d
    local shellCompDirectiveKeepOrder=%[8]d

    local lastParam lastChar flagPrefix requestComp out directive comp lastComp noSpace keepOrder
    local -a completions

    __%[1]s_debug "\n========= starting completion logic =========="
    __%[1]s_debug "CURRENT: ${CURRENT}, words[*]: ${words[*]}"

    # The user could have moved the cursor backwards on the command-line.
    # We need to trigger completion from the $CURRENT location, so we need
    # to truncate the command-line ($words) up to the $CURRENT location.
    # (We cannot use $CURSOR as its value does not work when a command is an alias.)
    words=("${=words[1,CURRENT]}")
    __%[1]s_debug "Truncated words[*]: ${words[*]},"

    lastParam=${words[-1]}
    lastChar=${lastParam[-1]}
    __%[1]s_debug "lastParam: ${lastParam}, lastChar: ${lastChar}"

    # For zsh, when completing a flag with an = (e.g., %[1]s -n=&lt;TAB&gt;)
    # completions must be prefixed with the flag
    setopt local_options BASH_REMATCH
    if [[ "${lastParam}" =~ '-.*=' ]]; then
        # We are dealing with a flag with an =
        flagPrefix="-P ${BASH_REMATCH}"
    fi

    # Prepare the command to obtain completions
    requestComp="${words[1]} %[2]s ${words[2,-1]}"
    if [ "${lastChar}" = "" ]; then
        # If the last parameter is complete (there is a space following it)
        # We add an extra empty parameter so we can indicate this to the go completion code.
        __%[1]s_debug "Adding extra empty parameter"
        requestComp="${requestComp} \"\""
    fi

    __%[1]s_debug "About to call: eval ${requestComp}"

    # Use eval to handle any environment variables and such
    out=$(eval ${requestComp} 2&gt;/dev/null)
    __%[1]s_debug "completion output: ${out}"

    # Extract the directive integer following a : from the last line
    local lastLine
    while IFS='\n' read -r line; do
        lastLine=${line}
    done &lt; &lt;(printf "%%s\n" "${out[@]}")
    __%[1]s_debug "last line: ${lastLine}"

    if [ "${lastLine[1]}" = : ]; then
        directive=${lastLine[2,-1]}
        # Remove the directive including the : and the newline
        local suffix
        (( suffix=${#lastLine}+2))
        out=${out[1,-$suffix]}
    else
        # There is no directive specified.  Leave $out as is.
        __%[1]s_debug "No directive found.  Setting do default"
        directive=0
    fi

    __%[1]s_debug "directive: ${directive}"
    __%[1]s_debug "completions: ${out}"
    __%[1]s_debug "flagPrefix: ${flagPrefix}"

    if [ $((directive &amp; shellCompDirectiveError)) -ne 0 ]; then
        __%[1]s_debug "Completion received error. Ignoring completions."
        return
    fi

    local activeHelpMarker="%[9]s"
    local endIndex=${#activeHelpMarker}
    local startIndex=$((${#activeHelpMarker}+1))
    local hasActiveHelp=0
    while IFS='\n' read -r comp; do
        # Check if this is an activeHelp statement (i.e., prefixed with $activeHelpMarker)
        if [ "${comp[1,$endIndex]}" = "$activeHelpMarker" ];then
            __%[1]s_debug "ActiveHelp found: $comp"
            comp="${comp[$startIndex,-1]}"
            if [ -n "$comp" ]; then
                compadd -x "${comp}"
                __%[1]s_debug "ActiveHelp will need delimiter"
                hasActiveHelp=1
            fi

            continue
        fi

        if [ -n "$comp" ]; then
            # If requested, completions are returned with a description.
            # The description is preceded by a TAB character.
            # For zsh's _describe, we need to use a : instead of a TAB.
            # We first need to escape any : as part of the completion itself.
            comp=${comp//:/\\:}

            local tab="$(printf '\t')"
            comp=${comp//$tab/:}

            __%[1]s_debug "Adding completion: ${comp}"
            completions+=${comp}
            lastComp=$comp
        fi
    done &lt; &lt;(printf "%%s\n" "${out[@]}")

    # Add a delimiter after the activeHelp statements, but only if:
    # - there are completions following the activeHelp statements, or
    # - file completion will be performed (so there will be choices after the activeHelp)
    if [ $hasActiveHelp -eq 1 ]; then
        if [ ${#completions} -ne 0 ] || [ $((directive &amp; shellCompDirectiveNoFileComp)) -eq 0 ]; then
            __%[1]s_debug "Adding activeHelp delimiter"
            compadd -x "--"
            hasActiveHelp=0
        fi
    fi

    if [ $((directive &amp; shellCompDirectiveNoSpace)) -ne 0 ]; then
        __%[1]s_debug "Activating nospace."
        noSpace="-S ''"
    fi

    if [ $((directive &amp; shellCompDirectiveKeepOrder)) -ne 0 ]; then
        __%[1]s_debug "Activating keep order."
        keepOrder="-V"
    fi

    if [ $((directive &amp; shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        # File extension filtering
        local filteringCmd
        filteringCmd='_files'
        for filter in ${completions[@]}; do
            if [ ${filter[1]} != '*' ]; then
                # zsh requires a glob pattern to do file filtering
                filter="\*.$filter"
            fi
            filteringCmd+=" -g $filter"
        done
        filteringCmd+=" ${flagPrefix}"

        __%[1]s_debug "File filtering command: $filteringCmd"
        _arguments '*:filename:'"$filteringCmd"
    elif [ $((directive &amp; shellCompDirectiveFilterDirs)) -ne 0 ]; then
        # File completion for directories only
        local subdir
        subdir="${completions[1]}"
        if [ -n "$subdir" ]; then
            __%[1]s_debug "Listing directories in $subdir"
            pushd "${subdir}" &gt;/dev/null 2&gt;&amp;1
        else
            __%[1]s_debug "Listing directories in ."
        fi

        local result
        _arguments '*:dirname:_files -/'" ${flagPrefix}"
        result=$?
        if [ -n "$subdir" ]; then
            popd &gt;/dev/null 2&gt;&amp;1
        fi
        return $result
    else
        __%[1]s_debug "Calling _describe"
        if eval _describe $keepOrder "completions" completions $flagPrefix $noSpace; then
            __%[1]s_debug "_describe found some completions"

            # Return the success of having called _describe
            return 0
        else
            __%[1]s_debug "_describe did not find completions."
            __%[1]s_debug "Checking if we should do file completion."
            if [ $((directive &amp; shellCompDirectiveNoFileComp)) -ne 0 ]; then
                __%[1]s_debug "deactivating file completion"

                # We must return an error code here to let zsh know that there were no
                # completions found by _describe; this is what will trigger other
                # matching algorithms to attempt to find completions.
                # For example zsh can match letters in the middle of words.
                return 1
            else
                # Perform file completion
                __%[1]s_debug "Activating file completion"

                # We must return the result of this command, so it must be the
                # last command, or else we must store its result to return it.
                _arguments '*:filename:_files'" ${flagPrefix}"
            fi
        fi
    fi
}

# don't run the completion function when being source-ed or eval-ed
if [ "$funcstack[1]" = "_%[1]s" ]; then
    _%[1]s
fi
`, name, compCmd,
                ShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,
                ShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder,
                activeHelpMarker))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
